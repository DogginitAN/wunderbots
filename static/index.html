<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Wunderbots</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
body { font-family:'Fredoka',sans-serif; overflow:hidden; height:100vh; height:100dvh; }
@keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.05)} }
@keyframes slideUp { from{opacity:0;transform:translateY(8px)} to{opacity:1;transform:translateY(0)} }
@keyframes typing { 0%{opacity:0.3} 50%{opacity:1} 100%{opacity:0.3} }
.typing-indicator { display:flex;gap:5px;padding:8px 20px;align-items:center; }
.typing-indicator .dot { width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.5);animation:typing 1.2s ease-in-out infinite; }
.typing-indicator .dot:nth-child(2) { animation-delay:0.2s; }
.typing-indicator .dot:nth-child(3) { animation-delay:0.4s; }
@keyframes slideDown { from{opacity:0;transform:translateY(-10px)} to{opacity:1;transform:translateY(0)} }
@keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-12px)} }
@keyframes starPop { from{opacity:0;transform:scale(0) rotate(-20deg)} to{opacity:1;transform:scale(1) rotate(0deg)} }
@keyframes twinkle { 0%,100%{opacity:0.3} 50%{opacity:1} }
@keyframes spin { from{transform:rotate(0deg)} to{transform:rotate(360deg)} }
@keyframes fadeIn { from{opacity:0} to{opacity:1} }
@keyframes speakPulse { 0%,100%{box-shadow:0 0 12px rgba(255,255,255,0.3)} 50%{box-shadow:0 0 24px rgba(255,255,255,0.6)} }
@keyframes micPulse { 0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.4)} 50%{box-shadow:0 0 0 12px rgba(239,68,68,0)} }

/* Home Screen */
.home { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;padding:32px;background:linear-gradient(135deg,#1E1B4B 0%,#312E81 30%,#4C1D95 60%,#7C3AED 100%);position:relative;overflow:hidden; }
.star { position:absolute;border-radius:50%;background:white; }
.home h1 { font-size:42px;font-weight:800;color:white;margin-bottom:8px;text-shadow:0 4px 16px rgba(0,0,0,0.3); }
.home .sub { font-size:20px;color:#C4B5FD;margin-bottom:32px; }
.question-input { width:100%;max-width:500px;display:flex;flex-direction:column;gap:12px;z-index:1; }
.question-input input { width:100%;padding:16px 20px;border-radius:20px;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);color:white;font-size:20px;font-family:'Fredoka',sans-serif;font-weight:500;outline:none;backdrop-filter:blur(8px); }
.question-input input::placeholder { color:rgba(255,255,255,0.5); }
.question-input input:focus { border-color:#FCD34D;background:rgba(255,255,255,0.15); }
.go-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#FCD34D,#F59E0B);color:#1E1B4B;border:4px solid white;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 8px 32px rgba(0,0,0,0.2);transition:transform 0.2s; }
.go-btn:active { transform:scale(0.95); }
.go-btn:disabled { opacity:0.5;cursor:not-allowed; }
.suggestions { display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-top:16px;z-index:1; }
.suggestions button { padding:8px 16px;border-radius:50px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.08);color:#C4B5FD;font-size:14px;font-family:'Fredoka',sans-serif;font-weight:500;cursor:pointer;backdrop-filter:blur(4px); }

/* Loading Screen */
.loading { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;background:linear-gradient(135deg,#1E1B4B 0%,#4C1D95 50%,#7C3AED 100%); }
.loading .spinner { animation:spin 2s linear infinite;font-size:56px;margin-bottom:20px; }
.loading .text { font-size:22px;font-weight:700;color:white;text-align:center; }
.loading .bots { margin-top:12px;font-size:32px;animation:pulse 1.5s ease-in-out infinite; }
.loading .status { margin-top:16px;font-size:14px;color:#C4B5FD; }

/* Player */
.player { height:100vh;height:100dvh;position:relative;overflow:hidden;display:flex;flex-direction:column;transition:background 1s ease; }
.player-bg { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-overlay { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-banner { position:relative;z-index:10;background:rgba(0,0,0,0.35);backdrop-filter:blur(12px);padding:12px 20px;border-bottom:1px solid rgba(255,255,255,0.1);flex-shrink:0; }
.player-banner .q { font-size:15px;font-weight:700;color:white;text-align:center; }
.scene-stream { position:relative;z-index:1;flex:1;overflow-y:auto;padding:8px 0 100px;-webkit-overflow-scrolling:touch; }
.tap-bar { position:absolute;bottom:0;left:0;right:0;padding:16px 0 28px;text-align:center;background:linear-gradient(transparent,rgba(0,0,0,0.5));cursor:pointer;z-index:20; }
.tap-bar span { font-size:15px;color:rgba(255,255,255,0.8);font-weight:600;background:rgba(255,255,255,0.15);padding:8px 24px;border-radius:50px;backdrop-filter:blur(4px); }

/* Scene Elements */
.act-header { text-align:center;padding:20px 16px 12px;animation:fadeIn 0.8s ease-out; }
.act-header .pill { display:inline-block;padding:6px 20px;border-radius:50px;background:rgba(0,0,0,0.2);backdrop-filter:blur(4px); }
.act-header .pill span { font-size:14px;font-weight:700;color:rgba(255,255,255,0.8);letter-spacing:1px; }

.dialogue-row { display:flex;gap:14px;padding:10px 20px;align-items:flex-start; }
.dialogue-row.latest { animation:slideUp 0.5s ease-out; }
.dialogue-row.past { opacity:0.85; }

.avatar { border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;border:3px solid white;transition:all 0.3s ease; }
.avatar.speaking { animation:speakPulse 1s ease-in-out infinite; }
.avatar .eyes { color:white;letter-spacing:4px;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .mouth { color:white;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .badge { position:absolute;top:-6px;right:-6px;background:white;border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 6px rgba(0,0,0,0.15); }

.bubble { background:rgba(255,255,255,0.92);border-radius:20px;border-top-left-radius:6px;padding:14px 18px;box-shadow:0 4px 16px rgba(0,0,0,0.08); }
.bubble .speaker { font-size:13px;font-weight:700;margin-bottom:4px;text-shadow:0 1px 4px rgba(0,0,0,0.3); }
.bubble .text { font-size:18px;line-height:1.6;color:#1E293B;font-weight:500; }

.transition-scene { display:flex;align-items:center;justify-content:center;min-height:200px;animation:slideUp 0.5s ease-out; }
.transition-scene .label { font-size:28px;font-weight:800;color:white;text-shadow:0 3px 12px rgba(0,0,0,0.5);background:rgba(0,0,0,0.35);padding:20px 36px;border-radius:50px;backdrop-filter:blur(8px);animation:pulse 1.5s ease-in-out infinite; }
.transition-past { text-align:center;padding:12px 0;opacity:0.6; }
.transition-past span { font-size:14px;color:white;background:rgba(0,0,0,0.2);padding:6px 16px;border-radius:50px; }

/* Quiz */
.quiz { background:rgba(255,255,255,0.95);border-radius:24px;padding:28px 24px;margin:16px;box-shadow:0 8px 32px rgba(0,0,0,0.12);border:3px solid #FCD34D;animation:slideUp 0.4s ease-out; }
.quiz .prompt { text-align:center;margin-bottom:20px; }
.quiz .prompt .emoji { font-size:28px;margin-bottom:8px; }
.quiz .prompt .question { font-size:20px;font-weight:700;color:#1E293B; }
.quiz .options { display:flex;flex-direction:column;gap:12px; }
.quiz .opt-btn { padding:16px 20px;border-radius:16px;border:2.5px solid #E2E8F0;background:white;cursor:pointer;font-size:18px;font-weight:600;text-align:left;font-family:'Fredoka',sans-serif;color:#1E293B;transition:all 0.2s ease;box-shadow:0 2px 8px rgba(0,0,0,0.06); }
.quiz .opt-btn.correct { background:#D1FAE5;border-color:#10B981;box-shadow:0 4px 16px rgba(16,185,129,0.2); }
.quiz .opt-btn.wrong { background:#FEE2E2;border-color:#EF4444;box-shadow:0 4px 16px rgba(239,68,68,0.2); }
.quiz .opt-btn.reveal-correct { background:#D1FAE5;border-color:rgba(16,185,129,0.4); }
.quiz .opt-btn.locked { cursor:default; }
.quiz .response { margin-top:16px;padding:16px 20px;border-radius:16px;animation:slideUp 0.3s ease-out; }
.quiz .response.good { background:#ECFDF5;border:2px solid #6EE7B7; }
.quiz .response.bad { background:#FFF7ED;border:2px solid #FDBA74; }
.quiz .response .text { font-size:17px;color:#1E293B;font-weight:500;line-height:1.5; }
.quiz .continue-btn { margin-top:14px;padding:12px 32px;border-radius:50px;background:linear-gradient(135deg,#7C3AED,#2563EB);color:white;border:none;font-size:17px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 4px 16px rgba(124,58,237,0.3); }

/* Celebration */
.celebration { text-align:center;padding:40px 24px; }
.celebration .big-emoji { font-size:64px;margin-bottom:16px;animation:bounce 0.8s ease-in-out infinite; }
.celebration .msg { font-size:24px;font-weight:800;color:#1E293B;margin-bottom:12px;line-height:1.4; }
.celebration .stars { display:flex;justify-content:center;gap:8px;margin-bottom:24px;font-size:32px; }
.celebration .again-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#F59E0B,#EF4444);color:white;border:none;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 6px 24px rgba(245,158,11,0.4); }

/* Flipbook Transitions */
.flipbook-overlay {
  position:fixed;inset:0;z-index:100;display:flex;align-items:center;justify-content:center;
  transition:opacity 0.4s ease;
}
.flipbook-frame {
  position:absolute;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;
  opacity:0;transition:opacity 0.5s ease;
}
.flipbook-frame.active { opacity:1; }
.flipbook-vehicle { position:relative;width:180px;height:180px; }

/* Rocket */
@keyframes rocketLift { 0%{transform:translateY(60px) scale(0.8)} 30%{transform:translateY(0) scale(1)} 100%{transform:translateY(0) scale(1)} }
@keyframes rocketFly { 0%{transform:translateY(0)} 100%{transform:translateY(-300px) scale(0.4);opacity:0} }
@keyframes rocketFlame { 0%,100%{transform:scaleY(1) scaleX(1)} 50%{transform:scaleY(1.3) scaleX(0.8)} }
@keyframes rocketShake { 0%,100%{transform:translateX(0)} 25%{transform:translateX(-2px)} 75%{transform:translateX(2px)} }

/* Submarine */
@keyframes subDive { 0%{transform:translateY(-40px)} 100%{transform:translateY(40px)} }
@keyframes subBob { 0%,100%{transform:rotate(-2deg)} 50%{transform:rotate(2deg)} }
@keyframes bubble { 0%{transform:translateY(0) scale(1);opacity:0.7} 100%{transform:translateY(-80px) scale(0.3);opacity:0} }

/* Balloon */
@keyframes balloonFloat { 0%{transform:translateY(40px)} 100%{transform:translateY(-20px)} }
@keyframes balloonSway { 0%,100%{transform:rotate(-3deg)} 50%{transform:rotate(3deg)} }

/* Destination reveal */
@keyframes destReveal { 0%{opacity:0;transform:scale(0.9) translateY(20px)} 100%{opacity:1;transform:scale(1) translateY(0)} }
@keyframes destGlow { 0%,100%{filter:brightness(1)} 50%{filter:brightness(1.2)} }

/* Postcard arrival */
@keyframes postcardIn { 0%{transform:scale(0.3) rotate(-10deg);opacity:0} 60%{transform:scale(1.05) rotate(2deg);opacity:1} 100%{transform:scale(1) rotate(0deg);opacity:1} }

/* Stars/particles */
@keyframes starTrail { 0%{transform:translateY(0);opacity:1} 100%{transform:translateY(60px);opacity:0} }
@keyframes bubbleRise { 0%{transform:translateY(0);opacity:0.6} 100%{transform:translateY(-120px);opacity:0} }
</style>
</head>
<body>
<div id="app"></div>
<script>
// â”€â”€â”€ WUNDERBOTS PLAYBACK ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRADIENTS = {
  clubhouse:        { bg:"linear-gradient(135deg,#FEF3C7 0%,#FDE68A 30%,#FBBF24 100%)", ov:"radial-gradient(circle at 20% 80%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ " },
  science_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"radial-gradient(circle at 30% 70%,rgba(59,130,246,0.2) 0%,transparent 50%)", emoji:"ğŸ”¬" },
  geology_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"", emoji:"ğŸª¨" },
  ocean_floor:      { bg:"linear-gradient(180deg,#0C4A6E 0%,#0369A1 40%,#0EA5E9 100%)", ov:"", emoji:"ğŸŒŠ" },
  outer_space:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E1B4B 40%,#312E81 100%)", ov:"", emoji:"ğŸš€" },
  rainforest:       { bg:"linear-gradient(135deg,#064E3B 0%,#047857 40%,#10B981 100%)", ov:"", emoji:"ğŸŒ¿" },
  arctic:           { bg:"linear-gradient(135deg,#E0F2FE 0%,#BAE6FD 40%,#7DD3FC 100%)", ov:"", emoji:"ğŸ§Š" },
  desert:           { bg:"linear-gradient(135deg,#FEF3C7 0%,#FCD34D 40%,#F59E0B 100%)", ov:"", emoji:"ğŸœï¸" },
  volcano_view:     { bg:"linear-gradient(180deg,#1E3A5F 0%,#DC2626 40%,#F97316 70%,#FCD34D 100%)", ov:"radial-gradient(circle at 50% 40%,rgba(239,68,68,0.4) 0%,transparent 40%)", emoji:"ğŸŒ‹" },
  underground:      { bg:"linear-gradient(180deg,#44403C 0%,#78716C 50%,#A8A29E 100%)", ov:"", emoji:"â›ï¸" },
  factory:          { bg:"linear-gradient(135deg,#6B7280 0%,#9CA3AF 40%,#D1D5DB 100%)", ov:"", emoji:"ğŸ­" },
  farm:             { bg:"linear-gradient(135deg,#84CC16 0%,#65A30D 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ¾" },
  hospital:         { bg:"linear-gradient(135deg,#F0FDF4 0%,#BBF7D0 40%,#86EFAC 100%)", ov:"", emoji:"ğŸ¥" },
  kitchen:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 30%,#F59E0B 60%,#D97706 100%)", ov:"radial-gradient(circle at 60% 40%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ‘¨â€ğŸ³" },
  museum:           { bg:"linear-gradient(135deg,#FEF9C3 0%,#FDE047 40%,#EAB308 100%)", ov:"", emoji:"ğŸ›ï¸" },
  observatory:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E293B 40%,#334155 70%,#475569 100%)", ov:"radial-gradient(circle at 50% 20%,rgba(99,102,241,0.3) 0%,transparent 40%)", emoji:"ğŸ”­" },
  weather_station:  { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#60A5FA 100%)", ov:"", emoji:"ğŸŒ¤ï¸" },
  garden:           { bg:"linear-gradient(135deg,#D9F99D 0%,#84CC16 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ»" },
  library:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#D97706 40%,#92400E 100%)", ov:"", emoji:"ğŸ“š" },
  power_plant:      { bg:"linear-gradient(135deg,#FEF08A 0%,#FACC15 40%,#EAB308 100%)", ov:"", emoji:"âš¡" },
  construction_site:{ bg:"linear-gradient(135deg,#FED7AA 0%,#FB923C 40%,#EA580C 100%)", ov:"", emoji:"ğŸ—ï¸" },
  music_studio:     { bg:"linear-gradient(135deg,#E9D5FF 0%,#A855F7 40%,#7C3AED 100%)", ov:"", emoji:"ğŸµ" },
  recycling_center: { bg:"linear-gradient(135deg,#D1FAE5 0%,#34D399 40%,#059669 100%)", ov:"", emoji:"â™»ï¸" },
  beehive_interior: { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 40%,#D97706 100%)", ov:"", emoji:"ğŸ" },
};
const DEFAULT_GRAD = { bg:"linear-gradient(135deg,#1E1B4B,#7C3AED)", ov:"", emoji:"âœ¨" };

const EYES = { neutral:"â— â—",excited:"â˜… â˜…",thinking:"â—‘ â—‘",surprised:"â—¯ â—¯",happy:"â—  â— ",explaining:"â— â—",silly:"âœ– â— ",shy:"â—¡ â—¡" };
const MOUTHS = { neutral:"â€”",excited:"D",thinking:"~",surprised:"O",happy:"â—¡",explaining:"â—‹",silly:"P",shy:"Â·" };

const SUGGESTIONS = [
  "Why is the sky blue?",
  "Why do volcanoes explode?",
  "How do airplanes fly?",
  "Why do we dream?",
  "How does the internet work?",
  "Why do leaves change color?",
  "What makes thunder?",
  "How do fish breathe underwater?",
];

let state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
let autoTimer = null;

// â”€â”€â”€ TTS AUDIO ENGINE (batch pre-generation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const audioCache = new Map();  // sceneKey -> blob URL
// Single persistent Audio element â€” Safari unlocks per-element, so reusing
// the same one that was played during the user gesture keeps it unlocked.
const persistentAudio = new Audio();
persistentAudio.preload = 'auto';
let currentSceneKey = null;
let ttsEnabled = true;

function sceneKey(aI, sI) { return aI+'-'+sI; }

// Generate ALL audio for an episode at once via /api/tts/batch
async function generateAllAudio(episode, onProgress) {
  try {
    if (onProgress) onProgress('Creating character voices...');
    
    const res = await fetch('/api/tts/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ episode })
    });
    
    if (!res.ok) {
      console.error('Batch TTS failed:', res.status);
      return 0;
    }
    
    const data = await res.json();
    const audioMap = data.audio || {};
    
    // Convert base64 to blob URLs and store in cache
    let loaded = 0;
    for (const [key, b64] of Object.entries(audioMap)) {
      try {
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const blob = new Blob([bytes], { type: 'audio/mpeg' });
        audioCache.set(key, URL.createObjectURL(blob));
        loaded++;
      } catch (e) {
        console.warn('Failed to decode audio for', key);
      }
    }
    
    if (onProgress) onProgress('Ready!');
    console.log('Batch TTS loaded:', loaded, 'scenes');
    return loaded;
  } catch (e) {
    console.error('Batch TTS error:', e);
    return 0;
  }
}

function playSceneAudio(actIdx, sceneIdx) {
  if (!ttsEnabled) { console.log('[AUDIO] TTS disabled, skipping'); return; }
  
  const key = sceneKey(actIdx, sceneIdx);
  const url = audioCache.get(key);
  if (!url) { console.log('[AUDIO] No audio in cache for', key); return; }

  // Get text length for fallback timing
  const scene = state.episode?.acts[actIdx]?.scenes[sceneIdx];
  const textLen = (scene?.text || '').length;
  const fallbackMs = Math.max(4000, textLen * 80);

  // Reuse the single persistent Audio element (Safari keeps it unlocked)
  persistentAudio.pause();
  currentSceneKey = key;
  persistentAudio.src = url;
  
  // Always set a fallback timer
  clearTimeout(autoTimer);
  autoTimer = setTimeout(() => {
    console.log('Audio fallback timer fired for', key);
    if (!state.waitingQuiz && !state.finished) advance();
  }, fallbackMs);

  persistentAudio.onended = () => {
    if (currentSceneKey === key) {
      currentSceneKey = null;
      if (!state.waitingQuiz && !state.finished) {
        clearTimeout(autoTimer);
        autoTimer = setTimeout(advance, 400);
      }
    }
  };

  persistentAudio.onerror = (e) => {
    console.warn('Audio error for', key, e);
    // Fallback timer handles advance
  };

  persistentAudio.play().then(() => {
    console.log('[AUDIO] Playing:', key);
  }).catch(e => {
    console.warn('[AUDIO] Play BLOCKED:', key, e.message);
    // Fallback timer handles advance
  });
}

function stopAudio() {
  persistentAudio.pause();
  currentSceneKey = null;
}

// â”€â”€â”€ RENDERING HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getGrad(key) { return GRADIENTS[key] || DEFAULT_GRAD; }

function avatar(char, emotion, size, speaking) {
  const e = emotion || "neutral";
  const sz = size || 56;
  return `<div class="avatar ${speaking?'speaking':''}" style="width:${sz}px;height:${sz}px;background:linear-gradient(135deg,${char.color},${char.accentColor});flex-shrink:0;${speaking?`box-shadow:0 0 20px ${char.color}88;border-color:${char.accentColor};transform:scale(1.1)`:'box-shadow:0 4px 12px rgba(0,0,0,0.15)'}">
    <div class="eyes" style="font-size:${sz*0.22}px;margin-top:-2px">${EYES[e]||EYES.neutral}</div>
    <div class="mouth" style="font-size:${sz*0.25}px;margin-top:2px">${MOUTHS[e]||MOUTHS.neutral}</div>
    <div class="badge" style="width:${sz*0.3}px;height:${sz*0.3}px;font-size:${sz*0.25}px">${char.emoji}</div>
  </div>`;
}

// â”€â”€â”€ SCREEN RENDERERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderHome() {
  const stars = Array.from({length:30}, (_,i) => {
    const x=Math.random()*100, y=Math.random()*100, s=Math.random()*4+2, d=Math.random()*3+2, dl=Math.random()*2;
    return `<div class="star" style="left:${x}%;top:${y}%;width:${s}px;height:${s}px;opacity:${Math.random()*0.7+0.3};animation:twinkle ${d}s ease-in-out infinite ${dl}s"></div>`;
  }).join('');
  
  const sugs = SUGGESTIONS.sort(()=>Math.random()-0.5).slice(0,4).map(q =>
    `<button onclick="pickSuggestion('${q.replace(/'/g,"\\'")}')">${q}</button>`
  ).join('');

  return `<div class="home">
    ${stars}
    <div style="text-align:center;z-index:1">
      <div style="font-size:48px;margin-bottom:8px">âœ¨</div>
      <h1>Wunderbots</h1>
      <p class="sub">What do you want to know?</p>
      <div class="question-input">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="qinput" type="text" placeholder="Ask any question..." autofocus
            onkeydown="if(event.key==='Enter')submitQuestion()" style="flex:1">
          <button id="mic-btn" onclick="toggleRecording()" style="width:56px;height:56px;border-radius:50%;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);font-size:28px;cursor:pointer;backdrop-filter:blur(8px);transition:all 0.2s;flex-shrink:0" onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">ğŸ¤</button>
        </div>
        <div id="mic-status" style="text-align:center;color:#FCD34D;font-size:15px;min-height:20px;font-weight:600"></div>
        <button class="go-btn" onclick="submitQuestion()">Let's Find Out! ğŸš€</button>
      </div>
      <div class="suggestions">${sugs}</div>
      <div style="width:100%;max-width:480px;margin-top:32px">
        <div style="text-align:center;margin-bottom:12px">
          <span style="font-size:14px;font-weight:700;color:#A78BFA;letter-spacing:1.5px;font-family:'Fredoka',sans-serif">
            ğŸ“š EPISODE LIBRARY
          </span>
        </div>
        <div id="library-list" style="max-height:320px;overflow-y:auto;padding:0 4px">
          <div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">Loading...</div>
        </div>
      </div>
    </div>
  </div>`;
}

function renderLoading() {
  return `<div class="loading">
    <div class="spinner" id="load-spinner">ğŸ”­</div>
    <div class="text" id="load-text">Finding experts to answer<br>your question...</div>
    <div class="bots" id="load-bots">â­ âš¡ ğŸŒ±</div>
    <div class="status" id="load-status">Researching...</div>
    <button id="start-btn" onclick="beginPlayback()" style="display:none;margin-top:24px;padding:20px 48px;border-radius:50px;background:linear-gradient(135deg,#FCD34D,#F59E0B);color:#1E1B4B;border:4px solid white;font-size:24px;font-weight:800;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 8px 32px rgba(0,0,0,0.3),0 0 60px rgba(252,211,77,0.4);animation:pulse 2s ease-in-out infinite">
      â–¶ Start Story!
    </button>
  </div>`;
}

function renderPlayer() {
  const ep = state.episode;
  const grad = getGrad(state.bgKey);

  // Only render the shell + first scene on initial call
  const firstScene = state.displayed.length > 0 ? renderScene(state.displayed[0].actIdx, state.displayed[0].sceneIdx, state.displayed.length === 1) : '';

  return `<div class="player" id="playerShell" style="background:${grad.bg}">
    <div class="player-bg" id="playerBg" style="background:${grad.ov}"></div>
    <div class="player-banner" style="display:flex;align-items:center;justify-content:space-between">
      <div style="flex:1"></div>
      <div class="q" style="flex:4;text-align:center">âœ¨ ${ep.question}</div>
      <div style="flex:1;text-align:right">
        <button id="soundBtn" onclick="toggleSound()" style="background:none;border:none;font-size:20px;cursor:pointer;opacity:0.7">${ttsEnabled ? 'ğŸ”Š' : 'ğŸ”‡'}</button>
      </div>
    </div>
    <div class="scene-stream" id="scroller">${firstScene}</div>
    <div class="tap-bar" id="tapBar" onclick="advance()"><span>Tap to continue â†’</span></div>
  </div>`;
}

// Append a single new scene to the existing scroller (no full re-render)
function appendScene(actIdx, sceneIdx) {
  const scroller = document.getElementById('scroller');
  if (!scroller) return;

  // Mark previous latest as past
  const prevLatest = scroller.querySelector('.dialogue-row.latest');
  if (prevLatest) {
    prevLatest.classList.remove('latest');
    prevLatest.classList.add('past');
    // Stop speaking animation on previous avatar
    const prevAvatar = prevLatest.querySelector('.avatar.speaking');
    if (prevAvatar) prevAvatar.classList.remove('speaking');
  }

  const sceneHtml = renderScene(actIdx, sceneIdx, true);
  const wrapper = document.createElement('div');
  wrapper.innerHTML = sceneHtml;
  while (wrapper.firstChild) scroller.appendChild(wrapper.firstChild);

  updatePlayerChrome();
  scrollBottom();
}

// Update background gradient and tap bar without full re-render
function updatePlayerChrome() {
  const grad = getGrad(state.bgKey);
  const shell = document.getElementById('playerShell');
  const bg = document.getElementById('playerBg');
  const tapBar = document.getElementById('tapBar');
  const scene = getCurrentScene();
  
  if (shell) { shell.style.transition = 'background 1.5s ease'; shell.style.background = grad.bg; }
  if (bg) { bg.style.transition = 'background 1.5s ease'; bg.style.background = grad.ov; }
  
  const showTap = !state.waitingQuiz && !state.finished && scene?.type !== "transition" && scene?.type !== "celebration";
  if (tapBar) tapBar.style.display = showTap ? '' : 'none';
}

function renderScene(aI, sI, isLatest) {
  const ep = state.episode;
  const act = ep.acts[aI];
  const scene = act.scenes[sI];
  const char = scene.character ? ep.characters[scene.character] : null;
  let html = '';

  // Act header on first scene
  if (sI === 0) {
    html += `<div class="act-header"><div class="pill"><span>PART ${act.act} Â· ${act.title.toUpperCase()}</span></div></div>`;
  }

  if (scene.type === "transition") {
    if (isLatest) {
      html += `<div class="transition-scene"><div class="label">${scene.text||''}</div></div>`;
    } else {
      html += `<div class="transition-past"><span>${scene.text||''}</span></div>`;
    }
  }

  if ((scene.type === "dialogue" || scene.type === "explanation") && char) {
    const cls = isLatest ? 'latest' : 'past';
    html += `<div class="dialogue-row ${cls}">
      <div style="flex-shrink:0;padding-top:4px">${avatar(char, scene.emotion, 56, isLatest)}</div>
      <div style="flex:1">
        <div class="bubble">
          <div class="speaker" style="color:${char.accentColor}">${char.name}</div>
          <div class="text">${scene.text||''}</div>
        </div>
      </div>
    </div>`;
  }

  if (scene.type === "quiz") {
    const qid = `quiz-${aI}-${sI}`;
    html += `<div class="quiz" id="${qid}">
      <div class="prompt"><div class="emoji">ğŸ¤”</div><div class="question">${scene.question}</div></div>
      <div class="options">
        ${scene.options.map((o,i) => `<button class="opt-btn" data-qi="${qid}" data-oi="${i}" data-correct="${o.correct}" onclick="handleQuiz(this)">${o.text}</button>`).join('')}
      </div>
    </div>`;
  }

  if (scene.type === "celebration" && isLatest) {
    html += `<div class="celebration">
      <div class="big-emoji">ğŸ‰</div>
      <div class="msg">${scene.text||'You did it!'}</div>
      <div class="stars">${['â­','ğŸ†','â­'].map((e,i) => `<span style="animation:starPop 0.4s ease-out ${i*0.15}s both">${e}</span>`).join('')}</div>
      <button class="again-btn" onclick="goHome()">Ask Another Question! ğŸ¤</button>
    </div>`;
  }

  return html;
}

// â”€â”€â”€ STATE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getCurrentScene() {
  if (!state.episode) return null;
  return state.episode.acts[state.actIdx]?.scenes[state.sceneIdx];
}

async function advance() {
  if (state.waitingQuiz || state.finished) { console.log('[ADVANCE] Blocked (quiz/finished)'); return; }
  clearTimeout(autoTimer);
  // DON'T stop audio here â€” let it finish naturally if still playing
  // New scene audio will replace it in playSceneAudio
  const ep = state.episode;
  const act = ep.acts[state.actIdx];

  if (state.sceneIdx < act.scenes.length - 1) {
    state.sceneIdx++;
  } else if (state.actIdx < ep.acts.length - 1) {
    state.actIdx++;
    state.sceneIdx = 0;
  } else {
    state.finished = true;
    updatePlayerChrome();
    return;
  }

  const next = ep.acts[state.actIdx].scenes[state.sceneIdx];
  state.displayed.push({ actIdx: state.actIdx, sceneIdx: state.sceneIdx });

  // Update background
  if (next.background && GRADIENTS[next.background]) state.bgKey = next.background;
  if (next.destination && GRADIENTS[next.destination]) state.bgKey = next.destination;

  if (next.type === "quiz") state.waitingQuiz = true;

  // Show typing indicator briefly before revealing the message
  if (next.type === "dialogue" || next.type === "explanation") {
    const char = next.character ? state.episode.characters[next.character] : null;
    if (char) {
      const scroller = document.getElementById('scroller');
      if (scroller) {
        const indicator = document.createElement('div');
        indicator.className = 'typing-indicator';
        indicator.id = 'typing';
        indicator.innerHTML = `
          <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg,${char.color},${char.accentColor});display:flex;align-items:center;justify-content:center;border:2px solid white;flex-shrink:0">
            <span style="font-size:12px">${char.emoji}</span>
          </div>
          <div style="background:rgba(255,255,255,0.7);border-radius:12px;padding:8px 14px;display:flex;gap:5px">
            <div class="dot"></div><div class="dot"></div><div class="dot"></div>
          </div>`;
        scroller.appendChild(indicator);
        scrollBottom();
      }
    }
  }

  // Brief pause for typing indicator, then show actual message
  await new Promise(r => setTimeout(r, next.type === "dialogue" || next.type === "explanation" ? 400 : 0));
  
  // Remove typing indicator
  const typing = document.getElementById('typing');
  if (typing) typing.remove();

  // Append just the new scene â€” no full re-render
  appendScene(state.actIdx, state.sceneIdx);

  // Play audio for dialogue/explanation scenes
  if ((next.type === "dialogue" || next.type === "explanation")) {
    const key = sceneKey(state.actIdx, state.sceneIdx);
    const hasAudio = ttsEnabled && audioCache.has(key);
    if (hasAudio) {
      // Audio exists â€” let it drive the pacing, no text timer
      playSceneAudio(state.actIdx, state.sceneIdx);
    } else {
      // No audio â€” use text timer
      const len = (next.text||'').length;
      autoTimer = setTimeout(advance, Math.max(3500, len * 75));
    }
  } else if (next.type === "transition") {
    // Flipbook animated transition
    playFlipbook(next, () => {
      if (!state.waitingQuiz && !state.finished) advance();
    });
    return; // playFlipbook handles timing
  } else if (next.type !== "quiz" && next.type !== "celebration") {
    const len = (next.text||'').length;
    autoTimer = setTimeout(advance, Math.max(3000, len * 70));
  }
}

function handleQuiz(btn) {
  const qi = btn.dataset.qi;
  const container = document.getElementById(qi);
  if (container.dataset.answered) return;
  container.dataset.answered = "true";

  const oi = parseInt(btn.dataset.oi);
  const isCorrect = btn.dataset.correct === "true";
  const scene = getCurrentScene();
  const opt = scene.options[oi];

  // Mark buttons
  container.querySelectorAll('.opt-btn').forEach((b,i) => {
    b.classList.add('locked');
    if (i === oi && isCorrect) b.classList.add('correct');
    if (i === oi && !isCorrect) b.classList.add('wrong');
    if (i !== oi && b.dataset.correct === "true") b.classList.add('reveal-correct');
    b.innerHTML += (i === oi && isCorrect) ? ' âœ…' : (i === oi && !isCorrect) ? ' âŒ' : (b.dataset.correct === "true" ? ' â† âœ…' : '');
  });

  // Show response
  const resp = document.createElement('div');
  resp.className = `response ${isCorrect ? 'good' : 'bad'}`;
  resp.innerHTML = `<div class="text">${isCorrect?'ğŸŒŸ':'ğŸ’¡'} ${opt.response}</div>
    <button class="continue-btn" onclick="quizDone()">${isCorrect ? 'Keep Going! ğŸš€' : "Let's Continue! â†’"}</button>`;
  container.appendChild(resp);
  scrollBottom();
}

function quizDone() {
  state.waitingQuiz = false;
  setTimeout(advance, 400);
}

function scrollBottom() {
  requestAnimationFrame(() => {
    const el = document.getElementById('scroller');
    if (!el) return;
    el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
  });
}

// â”€â”€â”€ NAVIGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function goHome() {
  loadLibrary(); // Refresh library in case a new episode was just generated
  stopAudio();
  audioCache.forEach(url => URL.revokeObjectURL(url));
  audioCache.clear();
  currentSceneKey = null;
  state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
  clearTimeout(autoTimer);
  render();
}

function pickSuggestion(q) {
  document.getElementById('qinput').value = q;
  submitQuestion();
}

async function submitQuestion() {
  const input = document.getElementById('qinput');
  const q = input.value.trim();
  if (!q) return;

  state.screen = "loading";
  render();

  try {
    const statusEl = document.getElementById('load-status');
    if (statusEl) statusEl.textContent = "Stage 1: Building the outline...";

    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ question: q })
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.error || 'Generation failed');
    }

    const episode = await res.json();
    await startEpisode(episode);

  } catch (err) {
    alert("Oops! " + err.message + "\n\nTry again?");
    goHome();
  }
}

// â”€â”€â”€ START EPISODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startEpisode(episode) {
  state.episode = episode;
  state.actIdx = 0;
  state.sceneIdx = 0;
  state.displayed = [{ actIdx: 0, sceneIdx: 0 }];
  state.waitingQuiz = false;
  state.finished = false;
  state.bgKey = "clubhouse";
  state.introduced = new Set();

  const first = episode.acts[0]?.scenes[0];
  if (first?.background && GRADIENTS[first.background]) state.bgKey = first.background;

  // Generate ALL audio before starting (loading screen stays visible)
  if (ttsEnabled) {
    const statusEl = document.getElementById('load-status');
    const count = await generateAllAudio(episode, msg => {
      if (statusEl) statusEl.textContent = msg;
    });
    console.log('All audio ready:', count, 'scenes');
  }

  // Show "Start Story" button â€” user tap gives us a fresh gesture for audio
  const spinner = document.getElementById('load-spinner');
  const text = document.getElementById('load-text');
  const bots = document.getElementById('load-bots');
  const status = document.getElementById('load-status');
  const btn = document.getElementById('start-btn');
  
  if (spinner) spinner.textContent = 'âœ¨';
  if (spinner) spinner.style.animation = 'bounce 0.8s ease-in-out infinite';
  if (text) text.innerHTML = 'Your story is ready!';
  if (bots) bots.style.display = 'none';
  if (status) status.textContent = '';
  if (btn) btn.style.display = 'inline-block';
}

// Called when user taps "Start Story" â€” THIS is the user gesture that unlocks audio
function beginPlayback() {
  // Unlock audio with this fresh gesture
  unlockAudio();
  
  const first = state.episode.acts[0]?.scenes[0];

  // Switch to player
  state.screen = "playing";
  render();

  // Play first scene â€” this tap IS the gesture, audio will work
  const firstKey = sceneKey(0, 0);
  if (ttsEnabled && audioCache.has(firstKey)) {
    playSceneAudio(0, 0);
  } else {
    const len = (first?.text||'').length;
    autoTimer = setTimeout(advance, Math.max(4000, len * 80));
  }
}

// iOS requires a user gesture to unlock audio playback.
// We create & play a silent audio on the first interaction.
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  // Unlock AudioContext for Safari
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = ctx.createBuffer(1, 1, 22050);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    src.start(0);
    ctx.close();
  } catch(e) {}
  // Unlock the PERSISTENT Audio element â€” this is the one we reuse for all playback.
  // Safari remembers that THIS element was played during a user gesture.
  try {
    persistentAudio.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV////////////////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQAAAAAAAAAAAGw9WraoAAAAAAAAAAAAAAAAAAAAP/jOMAAAQoAKAAATAD/ExBgAA0A+RJKxoEAAG9FI0AAAAATQN/4hH/wIIocTB0AAAA';
    persistentAudio.volume = 0;
    persistentAudio.play().then(() => {
      persistentAudio.pause();
      persistentAudio.volume = 1;
      persistentAudio.currentTime = 0;
      console.log('[AUDIO] Persistent element unlocked for Safari');
    }).catch(() => {});
  } catch(e) {}
  audioUnlocked = true;
}
document.addEventListener('click', unlockAudio);
document.addEventListener('touchstart', unlockAudio);

// â”€â”€â”€ VOICE INPUT (STT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;

async function startRecording() {
  try {
    // Check for secure context (HTTPS required for getUserMedia)
    if (!window.isSecureContext) {
      const micStatus = document.getElementById('mic-status');
      if (micStatus) micStatus.textContent = 'Needs HTTPS for mic access';
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Find a supported mimeType â€” Safari needs special handling
    let mimeType = '';
    for (const mt of ['audio/webm', 'audio/mp4', 'audio/aac', 'audio/ogg', 'audio/wav', '']) {
      if (mt === '' || MediaRecorder.isTypeSupported(mt)) { mimeType = mt; break; }
    }
    console.log('MediaRecorder mimeType:', mimeType || '(default)');
    // Create recorder â€” omit mimeType option if none supported (let browser pick)
    mediaRecorder = mimeType 
      ? new MediaRecorder(stream, { mimeType }) 
      : new MediaRecorder(stream);
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };
    
    mediaRecorder.onstop = async () => {
      // Stop all tracks to release the mic
      stream.getTracks().forEach(t => t.stop());
      
      const blobType = mediaRecorder.mimeType || 'audio/mp4';
      const audioBlob = new Blob(audioChunks, { type: blobType });
      console.log('Recording done:', audioChunks.length, 'chunks,', audioBlob.size, 'bytes, type:', blobType);
      
      const micBtn = document.getElementById('mic-btn');
      const micStatus = document.getElementById('mic-status');
      
      if (audioBlob.size < 500) {
        if (micStatus) micStatus.textContent = 'Recording too short â€” hold longer!';
        setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
        if (micBtn) { micBtn.textContent = 'ğŸ¤'; micBtn.style.opacity = '1'; }
        return;
      }
      
      // Show transcribing state
      if (micBtn) { micBtn.textContent = 'âœ¨'; micBtn.style.opacity = '0.5'; }
      if (micStatus) micStatus.textContent = 'Transcribing... (' + Math.round(audioBlob.size/1024) + 'KB)';
      
      try {
        const text = await transcribeAudio(audioBlob);
        if (text) {
          const input = document.getElementById('qinput');
          if (input) {
            input.value = text;
            input.focus();
          }
          if (micStatus) micStatus.textContent = '';
          // Auto-submit after a beat so they can see what was heard
          setTimeout(submitQuestion, 800);
        } else {
          if (micStatus) micStatus.textContent = "Didn't catch that â€” try again!";
          setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
        }
      } catch (err) {
        console.error('STT error:', err);
        if (micStatus) micStatus.textContent = 'Error: ' + (err.message || 'try again');
        setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 4000);
      }
      
      if (micBtn) { micBtn.textContent = 'ğŸ¤'; micBtn.style.opacity = '1'; }
      isRecording = false;
    };
    
    mediaRecorder.start();
    isRecording = true;
    const micBtn = document.getElementById('mic-btn');
    if (micBtn) {
      micBtn.textContent = 'â¹ï¸';
      micBtn.style.borderColor = '#EF4444';
      micBtn.style.background = 'rgba(239,68,68,0.2)';
      micBtn.style.animation = 'micPulse 1.5s ease-in-out infinite';
    }
    const micStatus = document.getElementById('mic-status');
    if (micStatus) micStatus.textContent = 'Listening... tap â¹ï¸ when done';
  } catch (err) {
    console.error('Mic error:', err.name, err.message);
    const micStatus = document.getElementById('mic-status');
    let msg = 'Mic access needed!';
    if (err.name === 'NotAllowedError') msg = 'Tap Allow when asked for mic access';
    else if (err.name === 'NotFoundError') msg = 'No microphone found';
    else if (err.name === 'NotSupportedError') msg = 'Mic not supported in this browser';
    if (micStatus) micStatus.textContent = msg;
    setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
}

function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
}

async function transcribeAudio(audioBlob) {
  const formData = new FormData();
  const ext = (audioBlob.type || '').includes('webm') ? 'webm' : (audioBlob.type || '').includes('ogg') ? 'ogg' : 'mp4';
  formData.append('audio', audioBlob, 'question.' + ext);
  console.log('Sending STT request:', audioBlob.size, 'bytes, ext:', ext);
  
  let res;
  try {
    res = await fetch('/api/stt', { method: 'POST', body: formData });
  } catch (fetchErr) {
    throw new Error('Network error: ' + fetchErr.message);
  }
  
  const bodyText = await res.text();
  console.log('STT response:', res.status, bodyText.slice(0, 200));
  
  if (!res.ok) {
    let msg = 'STT ' + res.status;
    try { msg = JSON.parse(bodyText).error || msg; } catch(e) {}
    throw new Error(msg);
  }
  
  try {
    const data = JSON.parse(bodyText);
    return data.text || '';
  } catch(e) {
    throw new Error('Bad response: ' + bodyText.slice(0, 100));
  }
}

// â”€â”€â”€ EPISODE LIBRARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let libraryEpisodes = [];

async function loadLibrary() {
  try {
    const res = await fetch('/api/library');
    if (!res.ok) return;
    const data = await res.json();
    libraryEpisodes = data.episodes || [];
    renderLibrary();
  } catch (e) {
    console.error('Library load error:', e);
  }
}

function renderLibrary() {
  const container = document.getElementById('library-list');
  if (!container) return;
  
  if (libraryEpisodes.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">No saved episodes yet â€” ask a question to get started!</div>';
    return;
  }
  
  container.innerHTML = libraryEpisodes.map(ep => `
    <button onclick="playLibraryEpisode('${ep.slug}')" style="
      display:block; width:100%; padding:16px 20px; margin-bottom:10px;
      background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.15);
      border-radius:16px; cursor:pointer; text-align:left;
      transition:all 0.2s; backdrop-filter:blur(4px);
    " onmouseenter="this.style.background='rgba(255,255,255,0.15)';this.style.borderColor='#FCD34D'"
       onmouseleave="this.style.background='rgba(255,255,255,0.08)';this.style.borderColor='rgba(255,255,255,0.15)'"
    >
      <div style="font-size:18px;font-weight:700;color:white;font-family:'Fredoka',sans-serif;margin-bottom:4px">
        âœ¨ ${ep.question}
      </div>
      <div style="font-size:13px;color:#C4B5FD;font-family:'Fredoka',sans-serif;line-height:1.4">
        ${ep.answer_summary || 'Tap to replay!'}
      </div>
    </button>
  `).join('');
}

async function playLibraryEpisode(slug) {
  state.screen = "loading";
  render();

  try {
    const statusEl = document.getElementById('load-status');
    if (statusEl) statusEl.textContent = 'Loading saved episode...';

    const res = await fetch('/api/library/' + slug);
    if (!res.ok) throw new Error('Episode not found');
    const episode = await res.json();
    await startEpisode(episode);
  } catch (e) {
    console.error('Library play error:', e);
    alert('Could not load episode â€” try again!');
    goHome();
  }
}

// Load library on page load
document.addEventListener('DOMContentLoaded', loadLibrary);

function toggleSound() {
  ttsEnabled = !ttsEnabled;
  if (!ttsEnabled) stopAudio();
  render();
}

// â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function render() {
  const app = document.getElementById('app');
  if (state.screen === "home") app.innerHTML = renderHome();
  else if (state.screen === "loading") app.innerHTML = renderLoading();
  else if (state.screen === "playing") app.innerHTML = renderPlayer();
}


// â”€â”€â”€ FLIPBOOK TRANSITION SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

const VEHICLE_SVG = {
  rocket: (chars) => `
    <svg viewBox="0 0 180 220" width="180" height="220" style="animation:rocketShake 0.15s ease-in-out infinite">
      <defs>
        <linearGradient id="rktBody" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#E2E8F0"/><stop offset="100%" stop-color="#94A3B8"/></linearGradient>
        <linearGradient id="rktNose" x1="0.5" y1="0" x2="0.5" y2="1"><stop offset="0%" stop-color="#EF4444"/><stop offset="100%" stop-color="#DC2626"/></linearGradient>
      </defs>
      <!-- Flame -->
      <g style="animation:rocketFlame 0.3s ease-in-out infinite">
        <ellipse cx="90" cy="205" rx="18" ry="14" fill="#FCD34D" opacity="0.9"/>
        <ellipse cx="90" cy="200" rx="12" ry="18" fill="#F97316"/>
        <ellipse cx="90" cy="195" rx="7" ry="12" fill="#FBBF24"/>
      </g>
      <!-- Body -->
      <rect x="65" y="70" width="50" height="110" rx="8" fill="url(#rktBody)" stroke="#64748B" stroke-width="2"/>
      <!-- Nose cone -->
      <path d="M65 70 Q90 15 115 70 Z" fill="url(#rktNose)" stroke="#B91C1C" stroke-width="2"/>
      <!-- Window -->
      <circle cx="90" cy="105" r="18" fill="#0EA5E9" stroke="#64748B" stroke-width="2"/>
      <circle cx="90" cy="105" r="14" fill="#38BDF8"/>
      <!-- Character emojis in window -->
      <text x="90" y="110" text-anchor="middle" font-size="14">${(chars||['â­','âš¡','ğŸŒ±']).join('')}</text>
      <!-- Fins -->
      <path d="M65 160 L48 185 L65 175 Z" fill="#EF4444" stroke="#B91C1C" stroke-width="1.5"/>
      <path d="M115 160 L132 185 L115 175 Z" fill="#EF4444" stroke="#B91C1C" stroke-width="1.5"/>
    </svg>`,

  submarine: (chars) => `
    <svg viewBox="0 0 220 140" width="220" height="140" style="animation:subBob 2s ease-in-out infinite">
      <defs>
        <linearGradient id="subBody" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#FCD34D"/><stop offset="100%" stop-color="#F59E0B"/></linearGradient>
      </defs>
      <!-- Body -->
      <ellipse cx="110" cy="80" rx="85" ry="38" fill="url(#subBody)" stroke="#D97706" stroke-width="2.5"/>
      <!-- Conning tower -->
      <rect x="88" y="38" width="35" height="30" rx="6" fill="#FBBF24" stroke="#D97706" stroke-width="2"/>
      <!-- Periscope -->
      <rect x="103" y="18" width="6" height="24" rx="3" fill="#64748B"/>
      <rect x="100" y="16" width="16" height="6" rx="3" fill="#64748B"/>
      <!-- Window -->
      <circle cx="110" cy="75" r="20" fill="#0EA5E9" stroke="#D97706" stroke-width="2"/>
      <circle cx="110" cy="75" r="16" fill="#7DD3FC"/>
      <text x="110" y="80" text-anchor="middle" font-size="14">${(chars||['â­','âš¡','ğŸŒ±']).join('')}</text>
      <!-- Propeller -->
      <circle cx="198" cy="80" r="4" fill="#64748B"/>
      <ellipse cx="205" cy="72" rx="3" ry="10" fill="#94A3B8" transform="rotate(20 205 72)"/>
      <ellipse cx="205" cy="88" rx="3" ry="10" fill="#94A3B8" transform="rotate(-20 205 88)"/>
      <!-- Portholes -->
      <circle cx="60" cy="80" r="8" fill="#BAE6FD" stroke="#D97706" stroke-width="1.5"/>
      <circle cx="160" cy="80" r="8" fill="#BAE6FD" stroke="#D97706" stroke-width="1.5"/>
    </svg>`,

  balloon: (chars) => `
    <svg viewBox="0 0 180 260" width="180" height="260" style="animation:balloonSway 3s ease-in-out infinite">
      <defs>
        <radialGradient id="ballGrad" cx="0.4" cy="0.3" r="0.6"><stop offset="0%" stop-color="#FB923C"/><stop offset="100%" stop-color="#EA580C"/></radialGradient>
      </defs>
      <!-- Balloon -->
      <ellipse cx="90" cy="80" rx="65" ry="78" fill="url(#ballGrad)" stroke="#C2410C" stroke-width="2"/>
      <!-- Highlight -->
      <ellipse cx="70" cy="60" rx="20" ry="30" fill="rgba(255,255,255,0.2)" transform="rotate(-15 70 60)"/>
      <!-- Stripes -->
      <path d="M50 40 Q90 120 55 155" fill="none" stroke="rgba(255,255,255,0.15)" stroke-width="8"/>
      <path d="M90 5 Q90 130 90 158" fill="none" stroke="rgba(255,255,255,0.1)" stroke-width="6"/>
      <!-- Ropes -->
      <line x1="65" y1="155" x2="60" y2="195" stroke="#92400E" stroke-width="1.5"/>
      <line x1="90" y1="158" x2="90" y2="195" stroke="#92400E" stroke-width="1.5"/>
      <line x1="115" y1="155" x2="120" y2="195" stroke="#92400E" stroke-width="1.5"/>
      <!-- Basket -->
      <rect x="55" y="195" width="70" height="40" rx="6" fill="#92400E" stroke="#78350F" stroke-width="2"/>
      <rect x="55" y="195" width="70" height="10" rx="4" fill="#A16207"/>
      <!-- Characters -->
      <text x="90" y="225" text-anchor="middle" font-size="18">${(chars||['â­','âš¡','ğŸŒ±']).join('')}</text>
    </svg>`
};

const DEST_SILHOUETTES = {
  geology_lab: { emoji: 'ğŸª¨', color: '#3B82F6', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><path d="M0 80 L30 40 L50 55 L80 20 L110 50 L140 30 L170 45 L200 15 L200 80Z" fill="currentColor" opacity="0.3"/><circle cx="160" cy="25" r="8" fill="currentColor" opacity="0.2"/></svg>' },
  kitchen: { emoji: 'ğŸ‘¨â€ğŸ³', color: '#D97706', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><rect x="20" y="30" width="60" height="50" rx="4" fill="currentColor" opacity="0.3"/><rect x="30" y="20" width="40" height="15" rx="8" fill="currentColor" opacity="0.2"/><rect x="120" y="40" width="50" height="40" rx="4" fill="currentColor" opacity="0.3"/><circle cx="145" cy="35" r="12" fill="currentColor" opacity="0.2"/></svg>' },
  volcano_view: { emoji: 'ğŸŒ‹', color: '#DC2626', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><path d="M0 80 L60 80 L85 15 L100 25 L115 15 L140 80 L200 80Z" fill="currentColor" opacity="0.3"/><ellipse cx="100" cy="12" rx="15" ry="8" fill="currentColor" opacity="0.15"/></svg>' },
  ocean_floor: { emoji: 'ğŸŒŠ', color: '#0EA5E9', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><path d="M0 60 Q25 40 50 60 Q75 80 100 60 Q125 40 150 60 Q175 80 200 60 L200 80 L0 80Z" fill="currentColor" opacity="0.3"/></svg>' },
  outer_space: { emoji: 'ğŸš€', color: '#6366F1', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><circle cx="40" cy="30" r="15" fill="currentColor" opacity="0.2"/><circle cx="140" cy="40" r="22" fill="currentColor" opacity="0.15"/><circle cx="170" cy="20" r="5" fill="currentColor" opacity="0.3"/></svg>' },
  rainforest: { emoji: 'ğŸŒ¿', color: '#16A34A', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><path d="M0 80 L20 80 L20 30 Q30 10 40 30 L40 80 L70 80 L70 20 Q85 0 100 25 L100 80 L130 80 L130 35 Q140 15 150 35 L150 80 L200 80Z" fill="currentColor" opacity="0.3"/></svg>' },
  clubhouse: { emoji: 'ğŸ ', color: '#FBBF24', silhouette: '<svg viewBox="0 0 200 80" width="200" height="80"><path d="M40 80 L40 40 L100 10 L160 40 L160 80Z" fill="currentColor" opacity="0.3"/><rect x="85" y="50" width="30" height="30" rx="2" fill="currentColor" opacity="0.2"/></svg>' },
  default: { emoji: 'âœ¨', color: '#A855F7', silhouette: '' }
};

function getDestInfo(dest) {
  return DEST_SILHOUETTES[dest] || DEST_SILHOUETTES.default;
}

function getVehicleType(scene) {
  // Use travel_mode from AI if available, otherwise infer from destination
  if (scene.travel_mode) return scene.travel_mode;
  const dest = (scene.destination || '').toLowerCase();
  if (dest.includes('ocean') || dest.includes('arctic') || dest.includes('underwater')) return 'submarine';
  if (dest.includes('garden') || dest.includes('farm') || dest.includes('museum') || dest.includes('kitchen') || dest.includes('library')) return 'balloon';
  return 'rocket';
}

function generateParticles(type) {
  const particles = [];
  const count = 12;
  if (type === 'rocket') {
    for (let i = 0; i < count; i++) {
      const x = 35 + Math.random() * 30;
      const delay = Math.random() * 2;
      const size = 2 + Math.random() * 3;
      particles.push('<div style="position:absolute;left:' + x + '%;top:55%;width:' + size + 'px;height:' + size + 'px;border-radius:50%;background:#FCD34D;animation:starTrail 1s ease-out ' + delay + 's infinite;opacity:0.7"></div>');
    }
  } else if (type === 'submarine') {
    for (let i = 0; i < count; i++) {
      const x = 20 + Math.random() * 60;
      const delay = Math.random() * 3;
      const size = 4 + Math.random() * 8;
      particles.push('<div style="position:absolute;left:' + x + '%;top:' + (40 + Math.random()*40) + '%;width:' + size + 'px;height:' + size + 'px;border-radius:50%;border:1.5px solid rgba(255,255,255,0.3);animation:bubbleRise 2.5s ease-out ' + delay + 's infinite"></div>');
    }
  } else { // balloon
    for (let i = 0; i < 8; i++) {
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const size = 1 + Math.random() * 2;
      particles.push('<div style="position:absolute;left:' + x + '%;top:' + y + '%;width:' + size + 'px;height:' + size + 'px;border-radius:50%;background:white;opacity:' + (0.3 + Math.random()*0.5) + ';animation:twinkle ' + (2+Math.random()*3) + 's ease-in-out infinite"></div>');
    }
  }
  return particles.join('');
}

function playFlipbook(scene, onDone) {
  const vehicle = getVehicleType(scene);
  const dest = scene.destination || '';
  const destInfo = getDestInfo(dest);
  const destGrad = getGrad(dest);
  const chars = ['â­', 'âš¡', 'ğŸŒ±'];
  const vehicleSvg = VEHICLE_SVG[vehicle] ? VEHICLE_SVG[vehicle](chars) : VEHICLE_SVG.rocket(chars);
  
  const overlay = document.createElement('div');
  overlay.className = 'flipbook-overlay';
  overlay.id = 'flipbook';
  
  const startGrad = getGrad(state.bgKey);
  
  const launchAnim = vehicle === 'rocket' ? 'rocketLift 1.2s ease-out forwards' :
                     vehicle === 'submarine' ? 'subDive 1.5s ease-in-out forwards' :
                     'balloonFloat 1.5s ease-out forwards';
  
  const travelAnim = vehicle === 'rocket' ? 'rocketFly 1.5s ease-in forwards' :
                     vehicle === 'submarine' ? 'subDive 2s ease-in-out infinite' :
                     'balloonFloat 2s ease-in-out infinite';

  // Static background on overlay itself â€” no gaps between frames
  // Starts with current location gradient, transitions to destination on frame 3
  overlay.style.background = startGrad.bg;
  overlay.style.transition = 'background 1s ease';

  // Frames only contain CONTENT, not backgrounds â€” overlay bg is always visible
  overlay.innerHTML = 
    '<div style="position:absolute;inset:0;background:rgba(0,0,0,0.15);pointer-events:none" id="fb-dim"></div>' +
    // Frame 1: Launch
    '<div class="flipbook-frame active" id="ff1">' +
      '<div class="flipbook-vehicle" style="animation:' + launchAnim + '">' + vehicleSvg + '</div>' +
      '<div style="position:absolute;bottom:40px;font-size:22px;font-weight:800;color:white;font-family:Fredoka,sans-serif;text-shadow:0 2px 8px rgba(0,0,0,0.5);text-align:center;padding:0 20px">' + (scene.text||'') + '</div>' +
    '</div>' +
    
    // Frame 2: Traveling (particles + vehicle)
    '<div class="flipbook-frame" id="ff2">' +
      '<div style="position:absolute;inset:0">' + generateParticles(vehicle) + '</div>' +
      '<div class="flipbook-vehicle" style="animation:' + travelAnim + '">' + vehicleSvg + '</div>' +
    '</div>' +
    
    // Frame 3: Destination reveal (emoji + silhouette)
    '<div class="flipbook-frame" id="ff3">' +
      '<div style="animation:destReveal 0.8s ease-out forwards;text-align:center">' +
        '<div style="font-size:72px;margin-bottom:12px;animation:destGlow 2s ease-in-out infinite">' + destInfo.emoji + '</div>' +
        '<div style="color:' + destInfo.color + ';position:relative">' + (destInfo.silhouette||'') + '</div>' +
      '</div>' +
      '<div style="position:absolute;bottom:60px;font-size:20px;font-weight:700;color:white;font-family:Fredoka,sans-serif;text-shadow:0 2px 8px rgba(0,0,0,0.5);background:rgba(0,0,0,0.3);padding:10px 28px;border-radius:50px;backdrop-filter:blur(4px)">Arriving...</div>' +
    '</div>' +
    
    // Frame 4: Postcard
    '<div class="flipbook-frame" id="ff4">' +
      '<div style="animation:postcardIn 0.6s ease-out forwards;background:rgba(255,255,255,0.95);border-radius:20px;padding:28px 32px;box-shadow:0 12px 40px rgba(0,0,0,0.25);text-align:center;max-width:320px">' +
        '<div style="font-size:48px;margin-bottom:8px">' + destInfo.emoji + '</div>' +
        '<div style="font-size:22px;font-weight:800;color:#1E293B;font-family:Fredoka,sans-serif;margin-bottom:4px">' + (dest.replace(/_/g,' ').replace(/\b\w/g,l=>l.toUpperCase())) + '</div>' +
        '<div style="font-size:14px;color:#64748B;font-family:Fredoka,sans-serif">â­ âš¡ ğŸŒ± have arrived!</div>' +
      '</div>' +
    '</div>';
  
  document.body.appendChild(overlay);
  
  // Sequence: show frame, hide previous â€” overlay bg stays solid throughout
  const timings = [0, 1500, 3500, 5000];
  const frames = ['ff1','ff2','ff3','ff4'];
  
  frames.forEach((fid, i) => {
    if (i === 0) return;
    setTimeout(() => {
      // Hide previous frame content
      const prev = document.getElementById(frames[i-1]);
      if (prev) prev.classList.remove('active');
      // Show current frame content
      const cur = document.getElementById(fid);
      if (cur) cur.classList.add('active');
      // On frame 3, transition the overlay background to destination
      if (i === 2) {
        overlay.style.background = destGrad.bg;
      }
    }, timings[i]);
  });
  
  // On the last frame, show a tap prompt â€” tapping dismisses AND provides
  // a fresh user gesture that keeps Safari audio unlocked for upcoming scenes.
  setTimeout(() => {
    const ff4 = document.getElementById('ff4');
    if (ff4) {
      // Add tap prompt to the postcard frame
      const tap = document.createElement('div');
      tap.style.cssText = 'position:absolute;bottom:24px;font-size:16px;font-weight:700;color:rgba(255,255,255,0.8);font-family:Fredoka,sans-serif;background:rgba(0,0,0,0.25);padding:10px 28px;border-radius:50px;backdrop-filter:blur(4px);animation:pulse 1.5s ease-in-out infinite;cursor:pointer';
      tap.textContent = 'Tap to continue â†’';
      ff4.appendChild(tap);
    }
    // Make the whole overlay tappable
    const el = document.getElementById('flipbook');
    if (el) {
      el.style.cursor = 'pointer';
      const dismiss = () => {
        el.removeEventListener('click', dismiss);
        el.removeEventListener('touchend', dismiss);
        // This tap IS the user gesture â€” re-unlock audio for Safari
        unlockAudio();
        el.style.opacity = '0';
        setTimeout(() => el.remove(), 300);
        if (onDone) onDone();
      };
      el.addEventListener('click', dismiss);
      el.addEventListener('touchend', dismiss);
      // Auto-dismiss fallback after 4s if they don't tap (desktop, etc.)
      setTimeout(() => {
        if (document.getElementById('flipbook')) {
          dismiss();
        }
      }, 4000);
    }
  }, 5000);
}
// Boot
render();
</script>
</body>
</html>
