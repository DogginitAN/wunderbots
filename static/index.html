<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Wunderbots</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
body { font-family:'Fredoka',sans-serif; overflow:hidden; height:100vh; height:100dvh; }
@keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.05)} }
@keyframes slideUp { from{opacity:0;transform:translateY(12px)} to{opacity:1;transform:translateY(0)} }
@keyframes typing { 0%{opacity:0.3} 50%{opacity:1} 100%{opacity:0.3} }
.typing-indicator { display:flex;gap:5px;padding:8px 20px;align-items:center; }
.typing-indicator .dot { width:8px;height:8px;border-radius:50%;background:rgba(255,255,255,0.5);animation:typing 1.2s ease-in-out infinite; }
.typing-indicator .dot:nth-child(2) { animation-delay:0.2s; }
.typing-indicator .dot:nth-child(3) { animation-delay:0.4s; }
@keyframes slideDown { from{opacity:0;transform:translateY(-10px)} to{opacity:1;transform:translateY(0)} }
@keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-12px)} }
@keyframes starPop { from{opacity:0;transform:scale(0) rotate(-20deg)} to{opacity:1;transform:scale(1) rotate(0deg)} }
@keyframes twinkle { 0%,100%{opacity:0.3} 50%{opacity:1} }
@keyframes spin { from{transform:rotate(0deg)} to{transform:rotate(360deg)} }
@keyframes speakPulse { 0%,100%{box-shadow:0 0 12px rgba(255,255,255,0.3)} 50%{box-shadow:0 0 24px rgba(255,255,255,0.6)} }
@keyframes micPulse { 0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.4)} 50%{box-shadow:0 0 0 12px rgba(239,68,68,0)} }

/* Home Screen */
.home { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;padding:32px;background:linear-gradient(135deg,#1E1B4B 0%,#312E81 30%,#4C1D95 60%,#7C3AED 100%);position:relative;overflow:hidden; }
.star { position:absolute;border-radius:50%;background:white; }
.home h1 { font-size:42px;font-weight:800;color:white;margin-bottom:8px;text-shadow:0 4px 16px rgba(0,0,0,0.3); }
.home .sub { font-size:20px;color:#C4B5FD;margin-bottom:32px; }
.question-input { width:100%;max-width:500px;display:flex;flex-direction:column;gap:12px;z-index:1; }
.question-input input { width:100%;padding:16px 20px;border-radius:20px;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);color:white;font-size:20px;font-family:'Fredoka',sans-serif;font-weight:500;outline:none;backdrop-filter:blur(8px); }
.question-input input::placeholder { color:rgba(255,255,255,0.5); }
.question-input input:focus { border-color:#FCD34D;background:rgba(255,255,255,0.15); }
.go-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#FCD34D,#F59E0B);color:#1E1B4B;border:4px solid white;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 8px 32px rgba(0,0,0,0.2);transition:transform 0.2s; }
.go-btn:active { transform:scale(0.95); }
.go-btn:disabled { opacity:0.5;cursor:not-allowed; }
.suggestions { display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-top:16px;z-index:1; }
.suggestions button { padding:8px 16px;border-radius:50px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.08);color:#C4B5FD;font-size:14px;font-family:'Fredoka',sans-serif;font-weight:500;cursor:pointer;backdrop-filter:blur(4px); }

/* Loading Screen */
.loading { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;background:linear-gradient(135deg,#1E1B4B 0%,#4C1D95 50%,#7C3AED 100%); }
.loading .spinner { animation:spin 2s linear infinite;font-size:56px;margin-bottom:20px; }
.loading .text { font-size:22px;font-weight:700;color:white;text-align:center; }
.loading .bots { margin-top:12px;font-size:32px;animation:pulse 1.5s ease-in-out infinite; }
.loading .status { margin-top:16px;font-size:14px;color:#C4B5FD; }

/* Player */
.player { height:100vh;height:100dvh;position:relative;overflow:hidden;display:flex;flex-direction:column;transition:background 1s ease; }
.player-bg { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-overlay { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-banner { position:relative;z-index:10;background:rgba(0,0,0,0.35);backdrop-filter:blur(12px);padding:12px 20px;border-bottom:1px solid rgba(255,255,255,0.1);flex-shrink:0; }
.player-banner .q { font-size:15px;font-weight:700;color:white;text-align:center; }
.scene-stream { position:relative;z-index:1;flex:1;overflow-y:auto;padding:8px 0 100px;-webkit-overflow-scrolling:touch; }
.tap-bar { position:absolute;bottom:0;left:0;right:0;padding:16px 0 28px;text-align:center;background:linear-gradient(transparent,rgba(0,0,0,0.5));cursor:pointer;z-index:20; }
.tap-bar span { font-size:15px;color:rgba(255,255,255,0.8);font-weight:600;background:rgba(255,255,255,0.15);padding:8px 24px;border-radius:50px;backdrop-filter:blur(4px); }

/* Scene Elements */
.act-header { text-align:center;padding:20px 16px 12px;animation:slideDown 0.4s ease-out; }
.act-header .pill { display:inline-block;padding:6px 20px;border-radius:50px;background:rgba(0,0,0,0.2);backdrop-filter:blur(4px); }
.act-header .pill span { font-size:14px;font-weight:700;color:rgba(255,255,255,0.8);letter-spacing:1px; }

.dialogue-row { display:flex;gap:14px;padding:10px 20px;align-items:flex-start; }
.dialogue-row.latest { animation:slideUp 0.5s ease-out; }
.dialogue-row.past { opacity:0.85; }

.avatar { border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;border:3px solid white;transition:all 0.3s ease; }
.avatar.speaking { animation:speakPulse 1s ease-in-out infinite; }
.avatar .eyes { color:white;letter-spacing:4px;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .mouth { color:white;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .badge { position:absolute;top:-6px;right:-6px;background:white;border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 6px rgba(0,0,0,0.15); }

.bubble { background:rgba(255,255,255,0.92);border-radius:20px;border-top-left-radius:6px;padding:14px 18px;box-shadow:0 4px 16px rgba(0,0,0,0.08); }
.bubble .speaker { font-size:13px;font-weight:700;margin-bottom:4px;text-shadow:0 1px 4px rgba(0,0,0,0.3); }
.bubble .text { font-size:18px;line-height:1.6;color:#1E293B;font-weight:500; }

.transition-scene { display:flex;align-items:center;justify-content:center;min-height:200px;animation:slideUp 0.5s ease-out; }
.transition-scene .label { font-size:28px;font-weight:800;color:white;text-shadow:0 3px 12px rgba(0,0,0,0.5);background:rgba(0,0,0,0.35);padding:20px 36px;border-radius:50px;backdrop-filter:blur(8px);animation:pulse 1.5s ease-in-out infinite; }
.transition-past { text-align:center;padding:12px 0;opacity:0.6; }
.transition-past span { font-size:14px;color:white;background:rgba(0,0,0,0.2);padding:6px 16px;border-radius:50px; }

/* Quiz */
.quiz { background:rgba(255,255,255,0.95);border-radius:24px;padding:28px 24px;margin:16px;box-shadow:0 8px 32px rgba(0,0,0,0.12);border:3px solid #FCD34D;animation:slideUp 0.4s ease-out; }
.quiz .prompt { text-align:center;margin-bottom:20px; }
.quiz .prompt .emoji { font-size:28px;margin-bottom:8px; }
.quiz .prompt .question { font-size:20px;font-weight:700;color:#1E293B; }
.quiz .options { display:flex;flex-direction:column;gap:12px; }
.quiz .opt-btn { padding:16px 20px;border-radius:16px;border:2.5px solid #E2E8F0;background:white;cursor:pointer;font-size:18px;font-weight:600;text-align:left;font-family:'Fredoka',sans-serif;color:#1E293B;transition:all 0.2s ease;box-shadow:0 2px 8px rgba(0,0,0,0.06); }
.quiz .opt-btn.correct { background:#D1FAE5;border-color:#10B981;box-shadow:0 4px 16px rgba(16,185,129,0.2); }
.quiz .opt-btn.wrong { background:#FEE2E2;border-color:#EF4444;box-shadow:0 4px 16px rgba(239,68,68,0.2); }
.quiz .opt-btn.reveal-correct { background:#D1FAE5;border-color:rgba(16,185,129,0.4); }
.quiz .opt-btn.locked { cursor:default; }
.quiz .response { margin-top:16px;padding:16px 20px;border-radius:16px;animation:slideUp 0.3s ease-out; }
.quiz .response.good { background:#ECFDF5;border:2px solid #6EE7B7; }
.quiz .response.bad { background:#FFF7ED;border:2px solid #FDBA74; }
.quiz .response .text { font-size:17px;color:#1E293B;font-weight:500;line-height:1.5; }
.quiz .continue-btn { margin-top:14px;padding:12px 32px;border-radius:50px;background:linear-gradient(135deg,#7C3AED,#2563EB);color:white;border:none;font-size:17px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 4px 16px rgba(124,58,237,0.3); }

/* Celebration */
.celebration { text-align:center;padding:40px 24px; }
.celebration .big-emoji { font-size:64px;margin-bottom:16px;animation:bounce 0.8s ease-in-out infinite; }
.celebration .msg { font-size:24px;font-weight:800;color:#1E293B;margin-bottom:12px;line-height:1.4; }
.celebration .stars { display:flex;justify-content:center;gap:8px;margin-bottom:24px;font-size:32px; }
.celebration .again-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#F59E0B,#EF4444);color:white;border:none;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 6px 24px rgba(245,158,11,0.4); }
</style>
</head>
<body>
<div id="app"></div>
<script>
// â”€â”€â”€ WUNDERBOTS PLAYBACK ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRADIENTS = {
  clubhouse:        { bg:"linear-gradient(135deg,#FEF3C7 0%,#FDE68A 30%,#FBBF24 100%)", ov:"radial-gradient(circle at 20% 80%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ " },
  science_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"radial-gradient(circle at 30% 70%,rgba(59,130,246,0.2) 0%,transparent 50%)", emoji:"ğŸ”¬" },
  geology_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"", emoji:"ğŸª¨" },
  ocean_floor:      { bg:"linear-gradient(180deg,#0C4A6E 0%,#0369A1 40%,#0EA5E9 100%)", ov:"", emoji:"ğŸŒŠ" },
  outer_space:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E1B4B 40%,#312E81 100%)", ov:"", emoji:"ğŸš€" },
  rainforest:       { bg:"linear-gradient(135deg,#064E3B 0%,#047857 40%,#10B981 100%)", ov:"", emoji:"ğŸŒ¿" },
  arctic:           { bg:"linear-gradient(135deg,#E0F2FE 0%,#BAE6FD 40%,#7DD3FC 100%)", ov:"", emoji:"ğŸ§Š" },
  desert:           { bg:"linear-gradient(135deg,#FEF3C7 0%,#FCD34D 40%,#F59E0B 100%)", ov:"", emoji:"ğŸœï¸" },
  volcano_view:     { bg:"linear-gradient(180deg,#1E3A5F 0%,#DC2626 40%,#F97316 70%,#FCD34D 100%)", ov:"radial-gradient(circle at 50% 40%,rgba(239,68,68,0.4) 0%,transparent 40%)", emoji:"ğŸŒ‹" },
  underground:      { bg:"linear-gradient(180deg,#44403C 0%,#78716C 50%,#A8A29E 100%)", ov:"", emoji:"â›ï¸" },
  factory:          { bg:"linear-gradient(135deg,#6B7280 0%,#9CA3AF 40%,#D1D5DB 100%)", ov:"", emoji:"ğŸ­" },
  farm:             { bg:"linear-gradient(135deg,#84CC16 0%,#65A30D 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ¾" },
  hospital:         { bg:"linear-gradient(135deg,#F0FDF4 0%,#BBF7D0 40%,#86EFAC 100%)", ov:"", emoji:"ğŸ¥" },
  kitchen:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 30%,#F59E0B 60%,#D97706 100%)", ov:"radial-gradient(circle at 60% 40%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ‘¨â€ğŸ³" },
  museum:           { bg:"linear-gradient(135deg,#FEF9C3 0%,#FDE047 40%,#EAB308 100%)", ov:"", emoji:"ğŸ›ï¸" },
  observatory:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E293B 40%,#334155 70%,#475569 100%)", ov:"radial-gradient(circle at 50% 20%,rgba(99,102,241,0.3) 0%,transparent 40%)", emoji:"ğŸ”­" },
  weather_station:  { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#60A5FA 100%)", ov:"", emoji:"ğŸŒ¤ï¸" },
  garden:           { bg:"linear-gradient(135deg,#D9F99D 0%,#84CC16 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ»" },
  library:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#D97706 40%,#92400E 100%)", ov:"", emoji:"ğŸ“š" },
  power_plant:      { bg:"linear-gradient(135deg,#FEF08A 0%,#FACC15 40%,#EAB308 100%)", ov:"", emoji:"âš¡" },
  construction_site:{ bg:"linear-gradient(135deg,#FED7AA 0%,#FB923C 40%,#EA580C 100%)", ov:"", emoji:"ğŸ—ï¸" },
  music_studio:     { bg:"linear-gradient(135deg,#E9D5FF 0%,#A855F7 40%,#7C3AED 100%)", ov:"", emoji:"ğŸµ" },
  recycling_center: { bg:"linear-gradient(135deg,#D1FAE5 0%,#34D399 40%,#059669 100%)", ov:"", emoji:"â™»ï¸" },
  beehive_interior: { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 40%,#D97706 100%)", ov:"", emoji:"ğŸ" },
};
const DEFAULT_GRAD = { bg:"linear-gradient(135deg,#1E1B4B,#7C3AED)", ov:"", emoji:"âœ¨" };

const EYES = { neutral:"â— â—",excited:"â˜… â˜…",thinking:"â—‘ â—‘",surprised:"â—¯ â—¯",happy:"â—  â— ",explaining:"â— â—",silly:"âœ– â— ",shy:"â—¡ â—¡" };
const MOUTHS = { neutral:"â€”",excited:"D",thinking:"~",surprised:"O",happy:"â—¡",explaining:"â—‹",silly:"P",shy:"Â·" };

const SUGGESTIONS = [
  "Why is the sky blue?",
  "Why do volcanoes explode?",
  "How do airplanes fly?",
  "Why do we dream?",
  "How does the internet work?",
  "Why do leaves change color?",
  "What makes thunder?",
  "How do fish breathe underwater?",
];

let state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
let autoTimer = null;

// â”€â”€â”€ TTS AUDIO ENGINE (batch pre-generation) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const audioCache = new Map();  // sceneKey -> blob URL
let currentAudio = null;
let ttsEnabled = true;

function sceneKey(aI, sI) { return aI+'-'+sI; }

// Generate ALL audio for an episode at once via /api/tts/batch
async function generateAllAudio(episode, onProgress) {
  try {
    if (onProgress) onProgress('Creating character voices...');
    
    const res = await fetch('/api/tts/batch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ episode })
    });
    
    if (!res.ok) {
      console.error('Batch TTS failed:', res.status);
      return 0;
    }
    
    const data = await res.json();
    const audioMap = data.audio || {};
    
    // Convert base64 to blob URLs and store in cache
    let loaded = 0;
    for (const [key, b64] of Object.entries(audioMap)) {
      try {
        const bytes = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const blob = new Blob([bytes], { type: 'audio/mpeg' });
        audioCache.set(key, URL.createObjectURL(blob));
        loaded++;
      } catch (e) {
        console.warn('Failed to decode audio for', key);
      }
    }
    
    if (onProgress) onProgress('Ready!');
    console.log('Batch TTS loaded:', loaded, 'scenes');
    return loaded;
  } catch (e) {
    console.error('Batch TTS error:', e);
    return 0;
  }
}

function playSceneAudio(actIdx, sceneIdx) {
  if (!ttsEnabled) return;
  if (currentAudio) { currentAudio.pause(); currentAudio = null; }
  const key = sceneKey(actIdx, sceneIdx);
  const url = audioCache.get(key);
  if (!url) return;

  // Get text length for fallback timing
  const scene = state.episode?.acts[actIdx]?.scenes[sceneIdx];
  const textLen = (scene?.text || '').length;
  const fallbackMs = Math.max(4000, textLen * 80); // generous text-based fallback

  currentAudio = new Audio(url);
  currentAudio._sceneKey = key;
  
  // Always set a fallback timer â€” if audio plays, onended clears it
  clearTimeout(autoTimer);
  autoTimer = setTimeout(() => {
    console.log('Audio fallback timer fired for', key);
    if (!state.waitingQuiz && !state.finished) advance();
  }, fallbackMs);

  currentAudio.onended = () => {
    if (currentAudio && currentAudio._sceneKey === key) {
      currentAudio = null;
      if (!state.waitingQuiz && !state.finished) {
        clearTimeout(autoTimer); // cancel fallback
        autoTimer = setTimeout(advance, 400);
      }
    }
  };

  currentAudio.onerror = (e) => {
    console.warn('Audio error for', key, e);
    // Fallback timer already set, will handle advance
  };

  currentAudio.play().catch(e => {
    console.warn('Audio play blocked:', e);
    // Fallback timer already set, will handle advance
  });
}

function stopAudio() {
  if (currentAudio) { currentAudio.pause(); currentAudio = null; }
}

// â”€â”€â”€ RENDERING HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getGrad(key) { return GRADIENTS[key] || DEFAULT_GRAD; }

function avatar(char, emotion, size, speaking) {
  const e = emotion || "neutral";
  const sz = size || 56;
  return `<div class="avatar ${speaking?'speaking':''}" style="width:${sz}px;height:${sz}px;background:linear-gradient(135deg,${char.color},${char.accentColor});flex-shrink:0;${speaking?`box-shadow:0 0 20px ${char.color}88;border-color:${char.accentColor};transform:scale(1.1)`:'box-shadow:0 4px 12px rgba(0,0,0,0.15)'}">
    <div class="eyes" style="font-size:${sz*0.22}px;margin-top:-2px">${EYES[e]||EYES.neutral}</div>
    <div class="mouth" style="font-size:${sz*0.25}px;margin-top:2px">${MOUTHS[e]||MOUTHS.neutral}</div>
    <div class="badge" style="width:${sz*0.3}px;height:${sz*0.3}px;font-size:${sz*0.25}px">${char.emoji}</div>
  </div>`;
}

// â”€â”€â”€ SCREEN RENDERERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderHome() {
  const stars = Array.from({length:30}, (_,i) => {
    const x=Math.random()*100, y=Math.random()*100, s=Math.random()*4+2, d=Math.random()*3+2, dl=Math.random()*2;
    return `<div class="star" style="left:${x}%;top:${y}%;width:${s}px;height:${s}px;opacity:${Math.random()*0.7+0.3};animation:twinkle ${d}s ease-in-out infinite ${dl}s"></div>`;
  }).join('');
  
  const sugs = SUGGESTIONS.sort(()=>Math.random()-0.5).slice(0,4).map(q =>
    `<button onclick="pickSuggestion('${q.replace(/'/g,"\\'")}')">${q}</button>`
  ).join('');

  return `<div class="home">
    ${stars}
    <div style="text-align:center;z-index:1">
      <div style="font-size:48px;margin-bottom:8px">âœ¨</div>
      <h1>Wunderbots</h1>
      <p class="sub">What do you want to know?</p>
      <div class="question-input">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="qinput" type="text" placeholder="Ask any question..." autofocus
            onkeydown="if(event.key==='Enter')submitQuestion()" style="flex:1">
          <button id="mic-btn" onclick="toggleRecording()" style="width:56px;height:56px;border-radius:50%;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);font-size:28px;cursor:pointer;backdrop-filter:blur(8px);transition:all 0.2s;flex-shrink:0" onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">ğŸ¤</button>
        </div>
        <div id="mic-status" style="text-align:center;color:#FCD34D;font-size:15px;min-height:20px;font-weight:600"></div>
        <button class="go-btn" onclick="submitQuestion()">Let's Find Out! ğŸš€</button>
      </div>
      <div class="suggestions">${sugs}</div>
      <div style="width:100%;max-width:480px;margin-top:32px">
        <div style="text-align:center;margin-bottom:12px">
          <span style="font-size:14px;font-weight:700;color:#A78BFA;letter-spacing:1.5px;font-family:'Fredoka',sans-serif">
            ğŸ“š EPISODE LIBRARY
          </span>
        </div>
        <div id="library-list" style="max-height:320px;overflow-y:auto;padding:0 4px">
          <div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">Loading...</div>
        </div>
      </div>
    </div>
  </div>`;
}

function renderLoading() {
  return `<div class="loading">
    <div class="spinner" id="load-spinner">ğŸ”­</div>
    <div class="text" id="load-text">Finding experts to answer<br>your question...</div>
    <div class="bots" id="load-bots">â­ âš¡ ğŸŒ±</div>
    <div class="status" id="load-status">Researching...</div>
    <button id="start-btn" onclick="beginPlayback()" style="display:none;margin-top:24px;padding:20px 48px;border-radius:50px;background:linear-gradient(135deg,#FCD34D,#F59E0B);color:#1E1B4B;border:4px solid white;font-size:24px;font-weight:800;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 8px 32px rgba(0,0,0,0.3),0 0 60px rgba(252,211,77,0.4);animation:pulse 2s ease-in-out infinite">
      â–¶ Start Story!
    </button>
  </div>`;
}

function renderPlayer() {
  const ep = state.episode;
  const grad = getGrad(state.bgKey);

  // Only render the shell + first scene on initial call
  const firstScene = state.displayed.length > 0 ? renderScene(state.displayed[0].actIdx, state.displayed[0].sceneIdx, state.displayed.length === 1) : '';

  return `<div class="player" id="playerShell" style="background:${grad.bg}">
    <div class="player-bg" id="playerBg" style="background:${grad.ov}"></div>
    <div class="player-banner" style="display:flex;align-items:center;justify-content:space-between">
      <div style="flex:1"></div>
      <div class="q" style="flex:4;text-align:center">âœ¨ ${ep.question}</div>
      <div style="flex:1;text-align:right">
        <button id="soundBtn" onclick="toggleSound()" style="background:none;border:none;font-size:20px;cursor:pointer;opacity:0.7">${ttsEnabled ? 'ğŸ”Š' : 'ğŸ”‡'}</button>
      </div>
    </div>
    <div class="scene-stream" id="scroller">${firstScene}</div>
    <div class="tap-bar" id="tapBar" onclick="advance()"><span>Tap to continue â†’</span></div>
  </div>`;
}

// Append a single new scene to the existing scroller (no full re-render)
function appendScene(actIdx, sceneIdx) {
  const scroller = document.getElementById('scroller');
  if (!scroller) return;

  // Mark previous latest as past
  const prevLatest = scroller.querySelector('.dialogue-row.latest');
  if (prevLatest) {
    prevLatest.classList.remove('latest');
    prevLatest.classList.add('past');
    // Stop speaking animation on previous avatar
    const prevAvatar = prevLatest.querySelector('.avatar.speaking');
    if (prevAvatar) prevAvatar.classList.remove('speaking');
  }

  const sceneHtml = renderScene(actIdx, sceneIdx, true);
  const wrapper = document.createElement('div');
  wrapper.innerHTML = sceneHtml;
  while (wrapper.firstChild) scroller.appendChild(wrapper.firstChild);

  updatePlayerChrome();
  scrollBottom();
}

// Update background gradient and tap bar without full re-render
function updatePlayerChrome() {
  const grad = getGrad(state.bgKey);
  const shell = document.getElementById('playerShell');
  const bg = document.getElementById('playerBg');
  const tapBar = document.getElementById('tapBar');
  const scene = getCurrentScene();
  
  if (shell) shell.style.background = grad.bg;
  if (bg) bg.style.background = grad.ov;
  
  const showTap = !state.waitingQuiz && !state.finished && scene?.type !== "transition" && scene?.type !== "celebration";
  if (tapBar) tapBar.style.display = showTap ? '' : 'none';
}

function renderScene(aI, sI, isLatest) {
  const ep = state.episode;
  const act = ep.acts[aI];
  const scene = act.scenes[sI];
  const char = scene.character ? ep.characters[scene.character] : null;
  let html = '';

  // Act header on first scene
  if (sI === 0) {
    html += `<div class="act-header"><div class="pill"><span>PART ${act.act} Â· ${act.title.toUpperCase()}</span></div></div>`;
  }

  if (scene.type === "transition") {
    if (isLatest) {
      html += `<div class="transition-scene"><div class="label">${scene.text||''}</div></div>`;
    } else {
      html += `<div class="transition-past"><span>${scene.text||''}</span></div>`;
    }
  }

  if ((scene.type === "dialogue" || scene.type === "explanation") && char) {
    const cls = isLatest ? 'latest' : 'past';
    html += `<div class="dialogue-row ${cls}">
      <div style="flex-shrink:0;padding-top:4px">${avatar(char, scene.emotion, 56, isLatest)}</div>
      <div style="flex:1">
        <div class="bubble">
          <div class="speaker" style="color:${char.accentColor}">${char.name}</div>
          <div class="text">${scene.text||''}</div>
        </div>
      </div>
    </div>`;
  }

  if (scene.type === "quiz") {
    const qid = `quiz-${aI}-${sI}`;
    html += `<div class="quiz" id="${qid}">
      <div class="prompt"><div class="emoji">ğŸ¤”</div><div class="question">${scene.question}</div></div>
      <div class="options">
        ${scene.options.map((o,i) => `<button class="opt-btn" data-qi="${qid}" data-oi="${i}" data-correct="${o.correct}" onclick="handleQuiz(this)">${o.text}</button>`).join('')}
      </div>
    </div>`;
  }

  if (scene.type === "celebration" && isLatest) {
    html += `<div class="celebration">
      <div class="big-emoji">ğŸ‰</div>
      <div class="msg">${scene.text||'You did it!'}</div>
      <div class="stars">${['â­','ğŸ†','â­'].map((e,i) => `<span style="animation:starPop 0.4s ease-out ${i*0.15}s both">${e}</span>`).join('')}</div>
      <button class="again-btn" onclick="goHome()">Ask Another Question! ğŸ¤</button>
    </div>`;
  }

  return html;
}

// â”€â”€â”€ STATE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getCurrentScene() {
  if (!state.episode) return null;
  return state.episode.acts[state.actIdx]?.scenes[state.sceneIdx];
}

async function advance() {
  if (state.waitingQuiz || state.finished) return;
  clearTimeout(autoTimer);
  // DON'T stop audio here â€” let it finish naturally if still playing
  // New scene audio will replace it in playSceneAudio
  const ep = state.episode;
  const act = ep.acts[state.actIdx];

  if (state.sceneIdx < act.scenes.length - 1) {
    state.sceneIdx++;
  } else if (state.actIdx < ep.acts.length - 1) {
    state.actIdx++;
    state.sceneIdx = 0;
  } else {
    state.finished = true;
    updatePlayerChrome();
    return;
  }

  const next = ep.acts[state.actIdx].scenes[state.sceneIdx];
  state.displayed.push({ actIdx: state.actIdx, sceneIdx: state.sceneIdx });

  // Update background
  if (next.background && GRADIENTS[next.background]) state.bgKey = next.background;
  if (next.destination && GRADIENTS[next.destination]) state.bgKey = next.destination;

  if (next.type === "quiz") state.waitingQuiz = true;

  // Show typing indicator briefly before revealing the message
  if (next.type === "dialogue" || next.type === "explanation") {
    const char = next.character ? state.episode.characters[next.character] : null;
    if (char) {
      const scroller = document.getElementById('scroller');
      if (scroller) {
        const indicator = document.createElement('div');
        indicator.className = 'typing-indicator';
        indicator.id = 'typing';
        indicator.innerHTML = `
          <div style="width:40px;height:40px;border-radius:50%;background:linear-gradient(135deg,${char.color},${char.accentColor});display:flex;align-items:center;justify-content:center;border:2px solid white;flex-shrink:0">
            <span style="font-size:12px">${char.emoji}</span>
          </div>
          <div style="background:rgba(255,255,255,0.7);border-radius:12px;padding:8px 14px;display:flex;gap:5px">
            <div class="dot"></div><div class="dot"></div><div class="dot"></div>
          </div>`;
        scroller.appendChild(indicator);
        scrollBottom();
      }
    }
  }

  // Brief pause for typing indicator, then show actual message
  await new Promise(r => setTimeout(r, next.type === "dialogue" || next.type === "explanation" ? 400 : 0));
  
  // Remove typing indicator
  const typing = document.getElementById('typing');
  if (typing) typing.remove();

  // Append just the new scene â€” no full re-render
  appendScene(state.actIdx, state.sceneIdx);

  // Play audio for dialogue/explanation scenes
  if ((next.type === "dialogue" || next.type === "explanation")) {
    const key = sceneKey(state.actIdx, state.sceneIdx);
    const hasAudio = ttsEnabled && audioCache.has(key);
    if (hasAudio) {
      // Audio exists â€” let it drive the pacing, no text timer
      playSceneAudio(state.actIdx, state.sceneIdx);
    } else {
      // No audio â€” use text timer
      const len = (next.text||'').length;
      autoTimer = setTimeout(advance, Math.max(3500, len * 75));
    }
  } else if (next.type === "transition") {
    autoTimer = setTimeout(advance, 3000);
  } else if (next.type !== "quiz" && next.type !== "celebration") {
    const len = (next.text||'').length;
    autoTimer = setTimeout(advance, Math.max(3000, len * 70));
  }
}

function handleQuiz(btn) {
  const qi = btn.dataset.qi;
  const container = document.getElementById(qi);
  if (container.dataset.answered) return;
  container.dataset.answered = "true";

  const oi = parseInt(btn.dataset.oi);
  const isCorrect = btn.dataset.correct === "true";
  const scene = getCurrentScene();
  const opt = scene.options[oi];

  // Mark buttons
  container.querySelectorAll('.opt-btn').forEach((b,i) => {
    b.classList.add('locked');
    if (i === oi && isCorrect) b.classList.add('correct');
    if (i === oi && !isCorrect) b.classList.add('wrong');
    if (i !== oi && b.dataset.correct === "true") b.classList.add('reveal-correct');
    b.innerHTML += (i === oi && isCorrect) ? ' âœ…' : (i === oi && !isCorrect) ? ' âŒ' : (b.dataset.correct === "true" ? ' â† âœ…' : '');
  });

  // Show response
  const resp = document.createElement('div');
  resp.className = `response ${isCorrect ? 'good' : 'bad'}`;
  resp.innerHTML = `<div class="text">${isCorrect?'ğŸŒŸ':'ğŸ’¡'} ${opt.response}</div>
    <button class="continue-btn" onclick="quizDone()">${isCorrect ? 'Keep Going! ğŸš€' : "Let's Continue! â†’"}</button>`;
  container.appendChild(resp);
  scrollBottom();
}

function quizDone() {
  state.waitingQuiz = false;
  setTimeout(advance, 400);
}

function scrollBottom() {
  setTimeout(() => {
    const el = document.getElementById('scroller');
    if (el) el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
  }, 250);
}

// â”€â”€â”€ NAVIGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function goHome() {
  loadLibrary(); // Refresh library in case a new episode was just generated
  stopAudio();
  audioCache.forEach(url => URL.revokeObjectURL(url));
  audioCache.clear();
  state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
  clearTimeout(autoTimer);
  render();
}

function pickSuggestion(q) {
  document.getElementById('qinput').value = q;
  submitQuestion();
}

async function submitQuestion() {
  const input = document.getElementById('qinput');
  const q = input.value.trim();
  if (!q) return;

  state.screen = "loading";
  render();

  try {
    const statusEl = document.getElementById('load-status');
    if (statusEl) statusEl.textContent = "Stage 1: Building the outline...";

    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ question: q })
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.error || 'Generation failed');
    }

    const episode = await res.json();
    await startEpisode(episode);

  } catch (err) {
    alert("Oops! " + err.message + "\n\nTry again?");
    goHome();
  }
}

// â”€â”€â”€ START EPISODE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
async function startEpisode(episode) {
  state.episode = episode;
  state.actIdx = 0;
  state.sceneIdx = 0;
  state.displayed = [{ actIdx: 0, sceneIdx: 0 }];
  state.waitingQuiz = false;
  state.finished = false;
  state.bgKey = "clubhouse";
  state.introduced = new Set();

  const first = episode.acts[0]?.scenes[0];
  if (first?.background && GRADIENTS[first.background]) state.bgKey = first.background;

  // Generate ALL audio before starting (loading screen stays visible)
  if (ttsEnabled) {
    const statusEl = document.getElementById('load-status');
    const count = await generateAllAudio(episode, msg => {
      if (statusEl) statusEl.textContent = msg;
    });
    console.log('All audio ready:', count, 'scenes');
  }

  // Show "Start Story" button â€” user tap gives us a fresh gesture for audio
  const spinner = document.getElementById('load-spinner');
  const text = document.getElementById('load-text');
  const bots = document.getElementById('load-bots');
  const status = document.getElementById('load-status');
  const btn = document.getElementById('start-btn');
  
  if (spinner) spinner.textContent = 'âœ¨';
  if (spinner) spinner.style.animation = 'bounce 0.8s ease-in-out infinite';
  if (text) text.innerHTML = 'Your story is ready!';
  if (bots) bots.style.display = 'none';
  if (status) status.textContent = '';
  if (btn) btn.style.display = 'inline-block';
}

// Called when user taps "Start Story" â€” THIS is the user gesture that unlocks audio
function beginPlayback() {
  // Unlock audio with this fresh gesture
  unlockAudio();
  
  const first = state.episode.acts[0]?.scenes[0];

  // Switch to player
  state.screen = "playing";
  render();

  // Play first scene â€” this tap IS the gesture, audio will work
  const firstKey = sceneKey(0, 0);
  if (ttsEnabled && audioCache.has(firstKey)) {
    playSceneAudio(0, 0);
  } else {
    const len = (first?.text||'').length;
    autoTimer = setTimeout(advance, Math.max(4000, len * 80));
  }
}

// iOS requires a user gesture to unlock audio playback.
// We create & play a silent audio on the first interaction.
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  // Unlock both AudioContext AND HTML Audio for Safari
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const buf = ctx.createBuffer(1, 1, 22050);
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.connect(ctx.destination);
    src.start(0);
    ctx.close();
  } catch(e) {}
  // Also warm up an HTML Audio element
  try {
    const a = new Audio();
    a.src = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA/+M4wAAAAAAAAAAAAEluZm8AAAAPAAAAAwAAAbAAqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV1dXV////////////////////////////////////////////AAAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQAAAAAAAAAAAGw9WraoAAAAAAAAAAAAAAAAAAAAP/jOMAAAQoAKAAATAD/ExBgAA0A+RJKxoEAAG9FI0AAAAATQN/4hH/wIIocTB0AAAA';
    a.volume = 0;
    a.play().then(() => a.pause()).catch(() => {});
  } catch(e) {}
  audioUnlocked = true;
}
document.addEventListener('click', unlockAudio);
document.addEventListener('touchstart', unlockAudio);

// â”€â”€â”€ VOICE INPUT (STT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;

async function startRecording() {
  try {
    // Check for secure context (HTTPS required for getUserMedia)
    if (!window.isSecureContext) {
      const micStatus = document.getElementById('mic-status');
      if (micStatus) micStatus.textContent = 'Needs HTTPS for mic access';
      return;
    }
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Find a supported mimeType â€” Safari needs special handling
    let mimeType = '';
    for (const mt of ['audio/webm', 'audio/mp4', 'audio/aac', 'audio/ogg', 'audio/wav', '']) {
      if (mt === '' || MediaRecorder.isTypeSupported(mt)) { mimeType = mt; break; }
    }
    console.log('MediaRecorder mimeType:', mimeType || '(default)');
    // Create recorder â€” omit mimeType option if none supported (let browser pick)
    mediaRecorder = mimeType 
      ? new MediaRecorder(stream, { mimeType }) 
      : new MediaRecorder(stream);
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };
    
    mediaRecorder.onstop = async () => {
      // Stop all tracks to release the mic
      stream.getTracks().forEach(t => t.stop());
      
      const blobType = mediaRecorder.mimeType || 'audio/mp4';
      const audioBlob = new Blob(audioChunks, { type: blobType });
      console.log('Recording done:', audioChunks.length, 'chunks,', audioBlob.size, 'bytes, type:', blobType);
      
      const micBtn = document.getElementById('mic-btn');
      const micStatus = document.getElementById('mic-status');
      
      if (audioBlob.size < 500) {
        if (micStatus) micStatus.textContent = 'Recording too short â€” hold longer!';
        setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
        if (micBtn) { micBtn.textContent = 'ğŸ¤'; micBtn.style.opacity = '1'; }
        return;
      }
      
      // Show transcribing state
      if (micBtn) { micBtn.textContent = 'âœ¨'; micBtn.style.opacity = '0.5'; }
      if (micStatus) micStatus.textContent = 'Transcribing... (' + Math.round(audioBlob.size/1024) + 'KB)';
      
      try {
        const text = await transcribeAudio(audioBlob);
        if (text) {
          const input = document.getElementById('qinput');
          if (input) {
            input.value = text;
            input.focus();
          }
          if (micStatus) micStatus.textContent = '';
          // Auto-submit after a beat so they can see what was heard
          setTimeout(submitQuestion, 800);
        } else {
          if (micStatus) micStatus.textContent = "Didn't catch that â€” try again!";
          setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
        }
      } catch (err) {
        console.error('STT error:', err);
        if (micStatus) micStatus.textContent = 'Error: ' + (err.message || 'try again');
        setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 4000);
      }
      
      if (micBtn) { micBtn.textContent = 'ğŸ¤'; micBtn.style.opacity = '1'; }
      isRecording = false;
    };
    
    mediaRecorder.start();
    isRecording = true;
    const micBtn = document.getElementById('mic-btn');
    if (micBtn) {
      micBtn.textContent = 'â¹ï¸';
      micBtn.style.borderColor = '#EF4444';
      micBtn.style.background = 'rgba(239,68,68,0.2)';
      micBtn.style.animation = 'micPulse 1.5s ease-in-out infinite';
    }
    const micStatus = document.getElementById('mic-status');
    if (micStatus) micStatus.textContent = 'Listening... tap â¹ï¸ when done';
  } catch (err) {
    console.error('Mic error:', err.name, err.message);
    const micStatus = document.getElementById('mic-status');
    let msg = 'Mic access needed!';
    if (err.name === 'NotAllowedError') msg = 'Tap Allow when asked for mic access';
    else if (err.name === 'NotFoundError') msg = 'No microphone found';
    else if (err.name === 'NotSupportedError') msg = 'Mic not supported in this browser';
    if (micStatus) micStatus.textContent = msg;
    setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
}

function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
}

async function transcribeAudio(audioBlob) {
  const formData = new FormData();
  const ext = (audioBlob.type || '').includes('webm') ? 'webm' : (audioBlob.type || '').includes('ogg') ? 'ogg' : 'mp4';
  formData.append('audio', audioBlob, 'question.' + ext);
  console.log('Sending STT request:', audioBlob.size, 'bytes, ext:', ext);
  
  let res;
  try {
    res = await fetch('/api/stt', { method: 'POST', body: formData });
  } catch (fetchErr) {
    throw new Error('Network error: ' + fetchErr.message);
  }
  
  const bodyText = await res.text();
  console.log('STT response:', res.status, bodyText.slice(0, 200));
  
  if (!res.ok) {
    let msg = 'STT ' + res.status;
    try { msg = JSON.parse(bodyText).error || msg; } catch(e) {}
    throw new Error(msg);
  }
  
  try {
    const data = JSON.parse(bodyText);
    return data.text || '';
  } catch(e) {
    throw new Error('Bad response: ' + bodyText.slice(0, 100));
  }
}

// â”€â”€â”€ EPISODE LIBRARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let libraryEpisodes = [];

async function loadLibrary() {
  try {
    const res = await fetch('/api/library');
    if (!res.ok) return;
    const data = await res.json();
    libraryEpisodes = data.episodes || [];
    renderLibrary();
  } catch (e) {
    console.error('Library load error:', e);
  }
}

function renderLibrary() {
  const container = document.getElementById('library-list');
  if (!container) return;
  
  if (libraryEpisodes.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">No saved episodes yet â€” ask a question to get started!</div>';
    return;
  }
  
  container.innerHTML = libraryEpisodes.map(ep => `
    <button onclick="playLibraryEpisode('${ep.slug}')" style="
      display:block; width:100%; padding:16px 20px; margin-bottom:10px;
      background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.15);
      border-radius:16px; cursor:pointer; text-align:left;
      transition:all 0.2s; backdrop-filter:blur(4px);
    " onmouseenter="this.style.background='rgba(255,255,255,0.15)';this.style.borderColor='#FCD34D'"
       onmouseleave="this.style.background='rgba(255,255,255,0.08)';this.style.borderColor='rgba(255,255,255,0.15)'"
    >
      <div style="font-size:18px;font-weight:700;color:white;font-family:'Fredoka',sans-serif;margin-bottom:4px">
        âœ¨ ${ep.question}
      </div>
      <div style="font-size:13px;color:#C4B5FD;font-family:'Fredoka',sans-serif;line-height:1.4">
        ${ep.answer_summary || 'Tap to replay!'}
      </div>
    </button>
  `).join('');
}

async function playLibraryEpisode(slug) {
  // Show loading
  document.getElementById('home').style.display = 'none';
  document.getElementById('loading').style.display = 'flex';
  document.getElementById('load-status').textContent = 'Loading saved episode...';
  
  try {
    const res = await fetch('/api/library/' + slug);
    if (!res.ok) throw new Error('Episode not found');
    const episode = await res.json();
    await startEpisode(episode);
  } catch (e) {
    console.error('Library play error:', e);
    document.getElementById('loading').style.display = 'none';
    document.getElementById('home').style.display = 'flex';
    alert('Could not load episode â€” try again!');
  }
}

// Load library on page load
document.addEventListener('DOMContentLoaded', loadLibrary);

function toggleSound() {
  ttsEnabled = !ttsEnabled;
  if (!ttsEnabled) stopAudio();
  render();
}

// â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function render() {
  const app = document.getElementById('app');
  if (state.screen === "home") app.innerHTML = renderHome();
  else if (state.screen === "loading") app.innerHTML = renderLoading();
  else if (state.screen === "playing") app.innerHTML = renderPlayer();
}

// Boot
render();
</script>
</body>
</html>
