<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>Wunderbots</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700;800&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
body { font-family:'Fredoka',sans-serif; overflow:hidden; height:100vh; height:100dvh; }
@keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.05)} }
@keyframes slideUp { from{opacity:0;transform:translateY(20px)} to{opacity:1;transform:translateY(0)} }
@keyframes slideDown { from{opacity:0;transform:translateY(-10px)} to{opacity:1;transform:translateY(0)} }
@keyframes bounce { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-12px)} }
@keyframes starPop { from{opacity:0;transform:scale(0) rotate(-20deg)} to{opacity:1;transform:scale(1) rotate(0deg)} }
@keyframes twinkle { 0%,100%{opacity:0.3} 50%{opacity:1} }
@keyframes spin { from{transform:rotate(0deg)} to{transform:rotate(360deg)} }
@keyframes speakPulse { 0%,100%{box-shadow:0 0 12px rgba(255,255,255,0.3)} 50%{box-shadow:0 0 24px rgba(255,255,255,0.6)} }
@keyframes micPulse { 0%,100%{box-shadow:0 0 0 0 rgba(239,68,68,0.4)} 50%{box-shadow:0 0 0 12px rgba(239,68,68,0)} }

/* Home Screen */
.home { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;padding:32px;background:linear-gradient(135deg,#1E1B4B 0%,#312E81 30%,#4C1D95 60%,#7C3AED 100%);position:relative;overflow:hidden; }
.star { position:absolute;border-radius:50%;background:white; }
.home h1 { font-size:42px;font-weight:800;color:white;margin-bottom:8px;text-shadow:0 4px 16px rgba(0,0,0,0.3); }
.home .sub { font-size:20px;color:#C4B5FD;margin-bottom:32px; }
.question-input { width:100%;max-width:500px;display:flex;flex-direction:column;gap:12px;z-index:1; }
.question-input input { width:100%;padding:16px 20px;border-radius:20px;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);color:white;font-size:20px;font-family:'Fredoka',sans-serif;font-weight:500;outline:none;backdrop-filter:blur(8px); }
.question-input input::placeholder { color:rgba(255,255,255,0.5); }
.question-input input:focus { border-color:#FCD34D;background:rgba(255,255,255,0.15); }
.go-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#FCD34D,#F59E0B);color:#1E1B4B;border:4px solid white;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 8px 32px rgba(0,0,0,0.2);transition:transform 0.2s; }
.go-btn:active { transform:scale(0.95); }
.go-btn:disabled { opacity:0.5;cursor:not-allowed; }
.suggestions { display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin-top:16px;z-index:1; }
.suggestions button { padding:8px 16px;border-radius:50px;border:2px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.08);color:#C4B5FD;font-size:14px;font-family:'Fredoka',sans-serif;font-weight:500;cursor:pointer;backdrop-filter:blur(4px); }

/* Loading Screen */
.loading { display:flex;flex-direction:column;align-items:center;justify-content:center;height:100vh;height:100dvh;background:linear-gradient(135deg,#1E1B4B 0%,#4C1D95 50%,#7C3AED 100%); }
.loading .spinner { animation:spin 2s linear infinite;font-size:56px;margin-bottom:20px; }
.loading .text { font-size:22px;font-weight:700;color:white;text-align:center; }
.loading .bots { margin-top:12px;font-size:32px;animation:pulse 1.5s ease-in-out infinite; }
.loading .status { margin-top:16px;font-size:14px;color:#C4B5FD; }

/* Player */
.player { height:100vh;height:100dvh;position:relative;overflow:hidden;display:flex;flex-direction:column;transition:background 1s ease; }
.player-bg { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-overlay { position:absolute;inset:0;z-index:0;pointer-events:none; }
.player-banner { position:relative;z-index:10;background:rgba(0,0,0,0.35);backdrop-filter:blur(12px);padding:12px 20px;border-bottom:1px solid rgba(255,255,255,0.1);flex-shrink:0; }
.player-banner .q { font-size:15px;font-weight:700;color:white;text-align:center; }
.scene-stream { position:relative;z-index:1;flex:1;overflow-y:auto;padding:8px 0 100px;-webkit-overflow-scrolling:touch; }
.tap-bar { position:absolute;bottom:0;left:0;right:0;padding:16px 0 28px;text-align:center;background:linear-gradient(transparent,rgba(0,0,0,0.5));cursor:pointer;z-index:20; }
.tap-bar span { font-size:15px;color:rgba(255,255,255,0.8);font-weight:600;background:rgba(255,255,255,0.15);padding:8px 24px;border-radius:50px;backdrop-filter:blur(4px); }

/* Scene Elements */
.act-header { text-align:center;padding:20px 16px 12px;animation:slideDown 0.4s ease-out; }
.act-header .pill { display:inline-block;padding:6px 20px;border-radius:50px;background:rgba(0,0,0,0.2);backdrop-filter:blur(4px); }
.act-header .pill span { font-size:14px;font-weight:700;color:rgba(255,255,255,0.8);letter-spacing:1px; }

.dialogue-row { display:flex;gap:14px;padding:10px 20px;align-items:flex-start; }
.dialogue-row.latest { animation:slideUp 0.4s ease-out; }
.dialogue-row.past { opacity:0.85; }

.avatar { border-radius:50%;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;border:3px solid white;transition:all 0.3s ease; }
.avatar.speaking { animation:speakPulse 1s ease-in-out infinite; }
.avatar .eyes { color:white;letter-spacing:4px;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .mouth { color:white;text-shadow:0 1px 2px rgba(0,0,0,0.3); }
.avatar .badge { position:absolute;top:-6px;right:-6px;background:white;border-radius:50%;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 6px rgba(0,0,0,0.15); }

.bubble { background:rgba(255,255,255,0.92);border-radius:20px;border-top-left-radius:6px;padding:14px 18px;box-shadow:0 4px 16px rgba(0,0,0,0.08); }
.bubble .speaker { font-size:13px;font-weight:700;margin-bottom:4px;text-shadow:0 1px 4px rgba(0,0,0,0.3); }
.bubble .text { font-size:18px;line-height:1.6;color:#1E293B;font-weight:500; }

.transition-scene { display:flex;align-items:center;justify-content:center;min-height:200px;animation:slideUp 0.5s ease-out; }
.transition-scene .label { font-size:28px;font-weight:800;color:white;text-shadow:0 3px 12px rgba(0,0,0,0.5);background:rgba(0,0,0,0.35);padding:20px 36px;border-radius:50px;backdrop-filter:blur(8px);animation:pulse 1.5s ease-in-out infinite; }
.transition-past { text-align:center;padding:12px 0;opacity:0.6; }
.transition-past span { font-size:14px;color:white;background:rgba(0,0,0,0.2);padding:6px 16px;border-radius:50px; }

/* Quiz */
.quiz { background:rgba(255,255,255,0.95);border-radius:24px;padding:28px 24px;margin:16px;box-shadow:0 8px 32px rgba(0,0,0,0.12);border:3px solid #FCD34D;animation:slideUp 0.4s ease-out; }
.quiz .prompt { text-align:center;margin-bottom:20px; }
.quiz .prompt .emoji { font-size:28px;margin-bottom:8px; }
.quiz .prompt .question { font-size:20px;font-weight:700;color:#1E293B; }
.quiz .options { display:flex;flex-direction:column;gap:12px; }
.quiz .opt-btn { padding:16px 20px;border-radius:16px;border:2.5px solid #E2E8F0;background:white;cursor:pointer;font-size:18px;font-weight:600;text-align:left;font-family:'Fredoka',sans-serif;color:#1E293B;transition:all 0.2s ease;box-shadow:0 2px 8px rgba(0,0,0,0.06); }
.quiz .opt-btn.correct { background:#D1FAE5;border-color:#10B981;box-shadow:0 4px 16px rgba(16,185,129,0.2); }
.quiz .opt-btn.wrong { background:#FEE2E2;border-color:#EF4444;box-shadow:0 4px 16px rgba(239,68,68,0.2); }
.quiz .opt-btn.reveal-correct { background:#D1FAE5;border-color:rgba(16,185,129,0.4); }
.quiz .opt-btn.locked { cursor:default; }
.quiz .response { margin-top:16px;padding:16px 20px;border-radius:16px;animation:slideUp 0.3s ease-out; }
.quiz .response.good { background:#ECFDF5;border:2px solid #6EE7B7; }
.quiz .response.bad { background:#FFF7ED;border:2px solid #FDBA74; }
.quiz .response .text { font-size:17px;color:#1E293B;font-weight:500;line-height:1.5; }
.quiz .continue-btn { margin-top:14px;padding:12px 32px;border-radius:50px;background:linear-gradient(135deg,#7C3AED,#2563EB);color:white;border:none;font-size:17px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 4px 16px rgba(124,58,237,0.3); }

/* Celebration */
.celebration { text-align:center;padding:40px 24px; }
.celebration .big-emoji { font-size:64px;margin-bottom:16px;animation:bounce 0.8s ease-in-out infinite; }
.celebration .msg { font-size:24px;font-weight:800;color:#1E293B;margin-bottom:12px;line-height:1.4; }
.celebration .stars { display:flex;justify-content:center;gap:8px;margin-bottom:24px;font-size:32px; }
.celebration .again-btn { padding:16px 40px;border-radius:50px;background:linear-gradient(135deg,#F59E0B,#EF4444);color:white;border:none;font-size:20px;font-weight:700;cursor:pointer;font-family:'Fredoka',sans-serif;box-shadow:0 6px 24px rgba(245,158,11,0.4); }
</style>
</head>
<body>
<div id="app"></div>
<script>
// â”€â”€â”€ WUNDERBOTS PLAYBACK ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GRADIENTS = {
  clubhouse:        { bg:"linear-gradient(135deg,#FEF3C7 0%,#FDE68A 30%,#FBBF24 100%)", ov:"radial-gradient(circle at 20% 80%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ " },
  science_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"radial-gradient(circle at 30% 70%,rgba(59,130,246,0.2) 0%,transparent 50%)", emoji:"ğŸ”¬" },
  geology_lab:      { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#3B82F6 100%)", ov:"", emoji:"ğŸª¨" },
  ocean_floor:      { bg:"linear-gradient(180deg,#0C4A6E 0%,#0369A1 40%,#0EA5E9 100%)", ov:"", emoji:"ğŸŒŠ" },
  outer_space:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E1B4B 40%,#312E81 100%)", ov:"", emoji:"ğŸš€" },
  rainforest:       { bg:"linear-gradient(135deg,#064E3B 0%,#047857 40%,#10B981 100%)", ov:"", emoji:"ğŸŒ¿" },
  arctic:           { bg:"linear-gradient(135deg,#E0F2FE 0%,#BAE6FD 40%,#7DD3FC 100%)", ov:"", emoji:"ğŸ§Š" },
  desert:           { bg:"linear-gradient(135deg,#FEF3C7 0%,#FCD34D 40%,#F59E0B 100%)", ov:"", emoji:"ğŸœï¸" },
  volcano_view:     { bg:"linear-gradient(180deg,#1E3A5F 0%,#DC2626 40%,#F97316 70%,#FCD34D 100%)", ov:"radial-gradient(circle at 50% 40%,rgba(239,68,68,0.4) 0%,transparent 40%)", emoji:"ğŸŒ‹" },
  underground:      { bg:"linear-gradient(180deg,#44403C 0%,#78716C 50%,#A8A29E 100%)", ov:"", emoji:"â›ï¸" },
  factory:          { bg:"linear-gradient(135deg,#6B7280 0%,#9CA3AF 40%,#D1D5DB 100%)", ov:"", emoji:"ğŸ­" },
  farm:             { bg:"linear-gradient(135deg,#84CC16 0%,#65A30D 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ¾" },
  hospital:         { bg:"linear-gradient(135deg,#F0FDF4 0%,#BBF7D0 40%,#86EFAC 100%)", ov:"", emoji:"ğŸ¥" },
  kitchen:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 30%,#F59E0B 60%,#D97706 100%)", ov:"radial-gradient(circle at 60% 40%,rgba(251,191,36,0.3) 0%,transparent 50%)", emoji:"ğŸ‘¨â€ğŸ³" },
  museum:           { bg:"linear-gradient(135deg,#FEF9C3 0%,#FDE047 40%,#EAB308 100%)", ov:"", emoji:"ğŸ›ï¸" },
  observatory:      { bg:"linear-gradient(180deg,#0F172A 0%,#1E293B 40%,#334155 70%,#475569 100%)", ov:"radial-gradient(circle at 50% 20%,rgba(99,102,241,0.3) 0%,transparent 40%)", emoji:"ğŸ”­" },
  weather_station:  { bg:"linear-gradient(135deg,#DBEAFE 0%,#93C5FD 40%,#60A5FA 100%)", ov:"", emoji:"ğŸŒ¤ï¸" },
  garden:           { bg:"linear-gradient(135deg,#D9F99D 0%,#84CC16 40%,#4D7C0F 100%)", ov:"", emoji:"ğŸŒ»" },
  library:          { bg:"linear-gradient(135deg,#FEF3C7 0%,#D97706 40%,#92400E 100%)", ov:"", emoji:"ğŸ“š" },
  power_plant:      { bg:"linear-gradient(135deg,#FEF08A 0%,#FACC15 40%,#EAB308 100%)", ov:"", emoji:"âš¡" },
  construction_site:{ bg:"linear-gradient(135deg,#FED7AA 0%,#FB923C 40%,#EA580C 100%)", ov:"", emoji:"ğŸ—ï¸" },
  music_studio:     { bg:"linear-gradient(135deg,#E9D5FF 0%,#A855F7 40%,#7C3AED 100%)", ov:"", emoji:"ğŸµ" },
  recycling_center: { bg:"linear-gradient(135deg,#D1FAE5 0%,#34D399 40%,#059669 100%)", ov:"", emoji:"â™»ï¸" },
  beehive_interior: { bg:"linear-gradient(135deg,#FEF3C7 0%,#FBBF24 40%,#D97706 100%)", ov:"", emoji:"ğŸ" },
};
const DEFAULT_GRAD = { bg:"linear-gradient(135deg,#1E1B4B,#7C3AED)", ov:"", emoji:"âœ¨" };

const EYES = { neutral:"â— â—",excited:"â˜… â˜…",thinking:"â—‘ â—‘",surprised:"â—¯ â—¯",happy:"â—  â— ",explaining:"â— â—",silly:"âœ– â— ",shy:"â—¡ â—¡" };
const MOUTHS = { neutral:"â€”",excited:"D",thinking:"~",surprised:"O",happy:"â—¡",explaining:"â—‹",silly:"P",shy:"Â·" };

const SUGGESTIONS = [
  "Why is the sky blue?",
  "Why do volcanoes explode?",
  "How do airplanes fly?",
  "Why do we dream?",
  "How does the internet work?",
  "Why do leaves change color?",
  "What makes thunder?",
  "How do fish breathe underwater?",
];

let state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
let autoTimer = null;

// â”€â”€â”€ TTS AUDIO ENGINE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const audioCache = new Map();
let currentAudio = null;
let ttsEnabled = true;

function sceneKey(aI, sI) { return aI+'-'+sI; }

async function fetchTTS(text, voice, emotion, slug, sceneKey) {
  // First: check if audio is cached in the library
  if (slug && sceneKey) {
    try {
      const cached = await fetch('/api/library/' + slug + '/audio/' + sceneKey);
      if (cached.ok) {
        const blob = await cached.blob();
        console.log('Audio cache hit:', sceneKey);
        return URL.createObjectURL(blob);
      }
    } catch (e) { /* cache miss, fall through to TTS */ }
  }
  
  // Not cached â€” generate via TTS and let server cache it
  try {
    const body = { text, voice, emotion };
    if (slug) body.slug = slug;
    if (sceneKey) body.scene_key = sceneKey;
    
    const res = await fetch('/api/tts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });
    if (!res.ok) return null;
    const blob = await res.blob();
    return URL.createObjectURL(blob);
  } catch (e) {
    console.warn('TTS fetch failed:', e);
    return null;
  }
}

function prefetchAudio(fromAct, fromScene, count) {
  if (!ttsEnabled || !state.episode) return;
  const ep = state.episode;
  const voiceMap = ep.voice_map || {};
  // Compute slug for caching
  const slug = ep.question ? ep.question.toLowerCase().replace(/[^\w\s-]/g,'').replace(/[\s_-]+/g,'-').slice(0,60).replace(/-$/,'') : '';
  let aI = fromAct, sI = fromScene, fetched = 0;
  while (fetched < count && aI < ep.acts.length) {
    const act = ep.acts[aI];
    if (sI < act.scenes.length) {
      const scene = act.scenes[sI];
      const key = sceneKey(aI, sI);
      if (!audioCache.has(key) && scene.text && (scene.type === 'dialogue' || scene.type === 'explanation')) {
        const voice = voiceMap[scene.character] || 'pNInz6obpgDQGcFmaJgB';
        const emotion = scene.emotion || 'neutral';
        fetchTTS(scene.text, voice, emotion, slug, key).then(url => { if (url) audioCache.set(key, url); });
        fetched++;
      }
      sI++;
    } else { aI++; sI = 0; }
  }
}

function playSceneAudio(actIdx, sceneIdx) {
  if (!ttsEnabled) return;
  if (currentAudio) { currentAudio.pause(); currentAudio = null; }
  const key = sceneKey(actIdx, sceneIdx);
  const url = audioCache.get(key);
  if (url) {
    currentAudio = new Audio(url);
    currentAudio.play().catch(e => console.warn('Audio play blocked:', e));
    currentAudio.onended = () => {
      currentAudio = null;
      if (!state.waitingQuiz && !state.finished) {
        autoTimer = setTimeout(advance, 800);
      }
    };
  }
  prefetchAudio(actIdx, sceneIdx + 1, 3);
}

function stopAudio() {
  if (currentAudio) { currentAudio.pause(); currentAudio = null; }
}

// â”€â”€â”€ RENDERING HELPERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getGrad(key) { return GRADIENTS[key] || DEFAULT_GRAD; }

function avatar(char, emotion, size, speaking) {
  const e = emotion || "neutral";
  const sz = size || 56;
  return `<div class="avatar ${speaking?'speaking':''}" style="width:${sz}px;height:${sz}px;background:linear-gradient(135deg,${char.color},${char.accentColor});flex-shrink:0;${speaking?`box-shadow:0 0 20px ${char.color}88;border-color:${char.accentColor};transform:scale(1.1)`:'box-shadow:0 4px 12px rgba(0,0,0,0.15)'}">
    <div class="eyes" style="font-size:${sz*0.22}px;margin-top:-2px">${EYES[e]||EYES.neutral}</div>
    <div class="mouth" style="font-size:${sz*0.25}px;margin-top:2px">${MOUTHS[e]||MOUTHS.neutral}</div>
    <div class="badge" style="width:${sz*0.3}px;height:${sz*0.3}px;font-size:${sz*0.25}px">${char.emoji}</div>
  </div>`;
}

// â”€â”€â”€ SCREEN RENDERERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function renderHome() {
  const stars = Array.from({length:30}, (_,i) => {
    const x=Math.random()*100, y=Math.random()*100, s=Math.random()*4+2, d=Math.random()*3+2, dl=Math.random()*2;
    return `<div class="star" style="left:${x}%;top:${y}%;width:${s}px;height:${s}px;opacity:${Math.random()*0.7+0.3};animation:twinkle ${d}s ease-in-out infinite ${dl}s"></div>`;
  }).join('');
  
  const sugs = SUGGESTIONS.sort(()=>Math.random()-0.5).slice(0,4).map(q =>
    `<button onclick="pickSuggestion('${q.replace(/'/g,"\\'")}')">${q}</button>`
  ).join('');

  return `<div class="home">
    ${stars}
    <div style="text-align:center;z-index:1">
      <div style="font-size:48px;margin-bottom:8px">âœ¨</div>
      <h1>Wunderbots</h1>
      <p class="sub">What do you want to know?</p>
      <div class="question-input">
        <div style="display:flex;gap:8px;align-items:center">
          <input id="qinput" type="text" placeholder="Ask any question..." autofocus
            onkeydown="if(event.key==='Enter')submitQuestion()" style="flex:1">
          <button id="mic-btn" onclick="toggleRecording()" style="width:56px;height:56px;border-radius:50%;border:3px solid rgba(255,255,255,0.3);background:rgba(255,255,255,0.1);font-size:28px;cursor:pointer;backdrop-filter:blur(8px);transition:all 0.2s;flex-shrink:0" onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">ğŸ¤</button>
        </div>
        <div id="mic-status" style="text-align:center;color:#FCD34D;font-size:15px;min-height:20px;font-weight:600"></div>
        <button class="go-btn" onclick="submitQuestion()">Let's Find Out! ğŸš€</button>
      </div>
      <div class="suggestions">${sugs}</div>
      <div style="width:100%;max-width:480px;margin-top:32px">
        <div style="text-align:center;margin-bottom:12px">
          <span style="font-size:14px;font-weight:700;color:#A78BFA;letter-spacing:1.5px;font-family:'Fredoka',sans-serif">
            ğŸ“š EPISODE LIBRARY
          </span>
        </div>
        <div id="library-list" style="max-height:320px;overflow-y:auto;padding:0 4px">
          <div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">Loading...</div>
        </div>
      </div>
    </div>
  </div>`;
}

function renderLoading() {
  return `<div class="loading">
    <div class="spinner">ğŸ”­</div>
    <div class="text">Finding experts to answer<br>your question...</div>
    <div class="bots">â­ âš¡ ğŸŒ±</div>
    <div class="status" id="load-status">Researching...</div>
  </div>`;
}

function renderPlayer() {
  const ep = state.episode;
  const grad = getGrad(state.bgKey);
  const showTap = !state.waitingQuiz && !state.finished && getCurrentScene()?.type !== "transition" && getCurrentScene()?.type !== "celebration";

  let scenesHtml = state.displayed.map((d,i) => renderScene(d.actIdx, d.sceneIdx, i === state.displayed.length-1)).join('');

  return `<div class="player" style="background:${grad.bg}">
    <div class="player-bg" style="background:${grad.ov}"></div>
    <div class="player-banner" style="display:flex;align-items:center;justify-content:space-between">
      <div style="flex:1"></div>
      <div class="q" style="flex:4;text-align:center">âœ¨ ${ep.question}</div>
      <div style="flex:1;text-align:right">
        <button onclick="toggleSound()" style="background:none;border:none;font-size:20px;cursor:pointer;opacity:0.7">${ttsEnabled ? 'ğŸ”Š' : 'ğŸ”‡'}</button>
      </div>
    </div>
    <div class="scene-stream" id="scroller">${scenesHtml}</div>
    ${showTap ? `<div class="tap-bar" onclick="advance()"><span>Tap to continue â†’</span></div>` : ''}
  </div>`;
}

function renderScene(aI, sI, isLatest) {
  const ep = state.episode;
  const act = ep.acts[aI];
  const scene = act.scenes[sI];
  const char = scene.character ? ep.characters[scene.character] : null;
  let html = '';

  // Act header on first scene
  if (sI === 0) {
    html += `<div class="act-header"><div class="pill"><span>PART ${act.act} Â· ${act.title.toUpperCase()}</span></div></div>`;
  }

  if (scene.type === "transition") {
    if (isLatest) {
      html += `<div class="transition-scene"><div class="label">${scene.text||''}</div></div>`;
    } else {
      html += `<div class="transition-past"><span>${scene.text||''}</span></div>`;
    }
  }

  if ((scene.type === "dialogue" || scene.type === "explanation") && char) {
    const cls = isLatest ? 'latest' : 'past';
    html += `<div class="dialogue-row ${cls}">
      <div style="flex-shrink:0;padding-top:4px">${avatar(char, scene.emotion, 56, isLatest)}</div>
      <div style="flex:1">
        <div class="bubble">
          <div class="speaker" style="color:${char.accentColor}">${char.name}</div>
          <div class="text">${scene.text||''}</div>
        </div>
      </div>
    </div>`;
  }

  if (scene.type === "quiz") {
    const qid = `quiz-${aI}-${sI}`;
    html += `<div class="quiz" id="${qid}">
      <div class="prompt"><div class="emoji">ğŸ¤”</div><div class="question">${scene.question}</div></div>
      <div class="options">
        ${scene.options.map((o,i) => `<button class="opt-btn" data-qi="${qid}" data-oi="${i}" data-correct="${o.correct}" onclick="handleQuiz(this)">${o.text}</button>`).join('')}
      </div>
    </div>`;
  }

  if (scene.type === "celebration" && isLatest) {
    html += `<div class="celebration">
      <div class="big-emoji">ğŸ‰</div>
      <div class="msg">${scene.text||'You did it!'}</div>
      <div class="stars">${['â­','ğŸ†','â­'].map((e,i) => `<span style="animation:starPop 0.4s ease-out ${i*0.15}s both">${e}</span>`).join('')}</div>
      <button class="again-btn" onclick="goHome()">Ask Another Question! ğŸ¤</button>
    </div>`;
  }

  return html;
}

// â”€â”€â”€ STATE MANAGEMENT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getCurrentScene() {
  if (!state.episode) return null;
  return state.episode.acts[state.actIdx]?.scenes[state.sceneIdx];
}

function advance() {
  if (state.waitingQuiz || state.finished) return;
  clearTimeout(autoTimer);
  stopAudio();
  const ep = state.episode;
  const act = ep.acts[state.actIdx];

  if (state.sceneIdx < act.scenes.length - 1) {
    state.sceneIdx++;
  } else if (state.actIdx < ep.acts.length - 1) {
    state.actIdx++;
    state.sceneIdx = 0;
  } else {
    state.finished = true;
    render();
    return;
  }

  const next = ep.acts[state.actIdx].scenes[state.sceneIdx];
  state.displayed.push({ actIdx: state.actIdx, sceneIdx: state.sceneIdx });

  // Update background
  if (next.background && GRADIENTS[next.background]) state.bgKey = next.background;
  if (next.destination && GRADIENTS[next.destination]) state.bgKey = next.destination;

  if (next.type === "quiz") state.waitingQuiz = true;

  render();
  scrollBottom();

  // Play audio for dialogue/explanation scenes
  if ((next.type === "dialogue" || next.type === "explanation") && ttsEnabled) {
    playSceneAudio(state.actIdx, state.sceneIdx);
    // Audio onended will handle auto-advance; set fallback timer
    const len = (next.text||'').length;
    autoTimer = setTimeout(advance, Math.max(5000, len * 100));
  } else if (next.type === "transition") {
    autoTimer = setTimeout(advance, 3000);
  } else if (next.type !== "quiz" && next.type !== "celebration") {
    const len = (next.text||'').length;
    autoTimer = setTimeout(advance, Math.max(3000, len * 70));
  }
}

function handleQuiz(btn) {
  const qi = btn.dataset.qi;
  const container = document.getElementById(qi);
  if (container.dataset.answered) return;
  container.dataset.answered = "true";

  const oi = parseInt(btn.dataset.oi);
  const isCorrect = btn.dataset.correct === "true";
  const scene = getCurrentScene();
  const opt = scene.options[oi];

  // Mark buttons
  container.querySelectorAll('.opt-btn').forEach((b,i) => {
    b.classList.add('locked');
    if (i === oi && isCorrect) b.classList.add('correct');
    if (i === oi && !isCorrect) b.classList.add('wrong');
    if (i !== oi && b.dataset.correct === "true") b.classList.add('reveal-correct');
    b.innerHTML += (i === oi && isCorrect) ? ' âœ…' : (i === oi && !isCorrect) ? ' âŒ' : (b.dataset.correct === "true" ? ' â† âœ…' : '');
  });

  // Show response
  const resp = document.createElement('div');
  resp.className = `response ${isCorrect ? 'good' : 'bad'}`;
  resp.innerHTML = `<div class="text">${isCorrect?'ğŸŒŸ':'ğŸ’¡'} ${opt.response}</div>
    <button class="continue-btn" onclick="quizDone()">${isCorrect ? 'Keep Going! ğŸš€' : "Let's Continue! â†’"}</button>`;
  container.appendChild(resp);
  scrollBottom();
}

function quizDone() {
  state.waitingQuiz = false;
  setTimeout(advance, 400);
}

function scrollBottom() {
  setTimeout(() => {
    const el = document.getElementById('scroller');
    if (el) el.scrollTo({ top: el.scrollHeight, behavior: 'smooth' });
  }, 100);
}

// â”€â”€â”€ NAVIGATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function goHome() {
  loadLibrary(); // Refresh library in case a new episode was just generated
  stopAudio();
  audioCache.forEach(url => URL.revokeObjectURL(url));
  audioCache.clear();
  state = { screen:"home", episode:null, actIdx:0, sceneIdx:0, displayed:[], waitingQuiz:false, finished:false, bgKey:"clubhouse", introduced:new Set() };
  clearTimeout(autoTimer);
  render();
}

function pickSuggestion(q) {
  document.getElementById('qinput').value = q;
  submitQuestion();
}

async function submitQuestion() {
  const input = document.getElementById('qinput');
  const q = input.value.trim();
  if (!q) return;

  state.screen = "loading";
  render();

  try {
    const statusEl = document.getElementById('load-status');
    if (statusEl) statusEl.textContent = "Stage 1: Building the outline...";

    const res = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ question: q })
    });

    if (!res.ok) {
      const err = await res.json();
      throw new Error(err.error || 'Generation failed');
    }

    const episode = await res.json();

    // Start playing
    state.screen = "playing";
    state.episode = episode;
    state.actIdx = 0;
    state.sceneIdx = 0;
    state.displayed = [{ actIdx: 0, sceneIdx: 0 }];
    state.waitingQuiz = false;
    state.finished = false;
    state.bgKey = "clubhouse";
    state.introduced = new Set();

    // Set initial background from first scene
    const first = episode.acts[0]?.scenes[0];
    if (first?.background && GRADIENTS[first.background]) state.bgKey = first.background;

    render();

    // Prefetch first batch of audio
    prefetchAudio(0, 0, 5);
    
    // Play first scene audio & start auto-advance
    if ((first?.type === 'dialogue' || first?.type === 'explanation') && ttsEnabled) {
      // Small delay to let first TTS fetch complete
      setTimeout(() => playSceneAudio(0, 0), 1500);
      const len = (first?.text||'').length;
      autoTimer = setTimeout(advance, Math.max(5000, len * 100));
    } else {
      const len = (first?.text||'').length;
      autoTimer = setTimeout(advance, Math.max(3000, len * 70));
    }

  } catch (err) {
    alert("Oops! " + err.message + "\n\nTry again?");
    goHome();
  }
}

// iOS requires a user gesture to unlock audio playback.
// We create & play a silent audio on the first interaction.
let audioUnlocked = false;
function unlockAudio() {
  if (audioUnlocked) return;
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  const buf = ctx.createBuffer(1, 1, 22050);
  const src = ctx.createBufferSource();
  src.buffer = buf;
  src.connect(ctx.destination);
  src.start(0);
  audioUnlocked = true;
  ctx.close();
}
document.addEventListener('click', unlockAudio, { once: true });
document.addEventListener('touchstart', unlockAudio, { once: true });

// â”€â”€â”€ VOICE INPUT (STT) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;

async function startRecording() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    // Use webm â€” Whisper supports it and it's well supported by browsers
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (e) => {
      if (e.data.size > 0) audioChunks.push(e.data);
    };
    
    mediaRecorder.onstop = async () => {
      // Stop all tracks to release the mic
      stream.getTracks().forEach(t => t.stop());
      
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      if (audioBlob.size < 1000) return; // too short, ignore
      
      // Show transcribing state
      const micBtn = document.getElementById('mic-btn');
      if (micBtn) { micBtn.textContent = 'âœ¨'; micBtn.style.opacity = '0.5'; }
      const micStatus = document.getElementById('mic-status');
      if (micStatus) micStatus.textContent = 'Listening...';
      
      try {
        const text = await transcribeAudio(audioBlob);
        if (text) {
          const input = document.getElementById('qinput');
          if (input) {
            input.value = text;
            input.focus();
          }
          if (micStatus) micStatus.textContent = '';
          // Auto-submit after a beat so they can see what was heard
          setTimeout(submitQuestion, 800);
        } else {
          if (micStatus) micStatus.textContent = "Didn't catch that â€” try again!";
          setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 2500);
        }
      } catch (err) {
        console.error('STT error:', err);
        if (micStatus) micStatus.textContent = "Oops, try again!";
        setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 2500);
      }
      
      if (micBtn) { micBtn.textContent = 'ğŸ¤'; micBtn.style.opacity = '1'; }
      isRecording = false;
    };
    
    mediaRecorder.start();
    isRecording = true;
    const micBtn = document.getElementById('mic-btn');
    if (micBtn) {
      micBtn.textContent = 'â¹ï¸';
      micBtn.style.borderColor = '#EF4444';
      micBtn.style.background = 'rgba(239,68,68,0.2)';
      micBtn.style.animation = 'micPulse 1.5s ease-in-out infinite';
    }
    const micStatus = document.getElementById('mic-status');
    if (micStatus) micStatus.textContent = 'Listening... tap â¹ï¸ when done';
  } catch (err) {
    console.error('Mic access denied:', err);
    const micStatus = document.getElementById('mic-status');
    if (micStatus) micStatus.textContent = 'Mic access needed!';
    setTimeout(() => { if (micStatus) micStatus.textContent = ''; }, 3000);
  }
}

function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    mediaRecorder.stop();
  }
}

function toggleRecording() {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
}

async function transcribeAudio(audioBlob) {
  const formData = new FormData();
  formData.append('audio', audioBlob, 'question.webm');
  
  const res = await fetch('/api/stt', {
    method: 'POST',
    body: formData
  });
  
  if (!res.ok) {
    const err = await res.json();
    throw new Error(err.error || 'Transcription failed');
  }
  
  const data = await res.json();
  return data.text || '';
}

// â”€â”€â”€ EPISODE LIBRARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let libraryEpisodes = [];

async function loadLibrary() {
  try {
    const res = await fetch('/api/library');
    if (!res.ok) return;
    const data = await res.json();
    libraryEpisodes = data.episodes || [];
    renderLibrary();
  } catch (e) {
    console.error('Library load error:', e);
  }
}

function renderLibrary() {
  const container = document.getElementById('library-list');
  if (!container) return;
  
  if (libraryEpisodes.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:#A78BFA;font-size:15px;padding:12px">No saved episodes yet â€” ask a question to get started!</div>';
    return;
  }
  
  container.innerHTML = libraryEpisodes.map(ep => `
    <button onclick="playLibraryEpisode('${ep.slug}')" style="
      display:block; width:100%; padding:16px 20px; margin-bottom:10px;
      background:rgba(255,255,255,0.08); border:2px solid rgba(255,255,255,0.15);
      border-radius:16px; cursor:pointer; text-align:left;
      transition:all 0.2s; backdrop-filter:blur(4px);
    " onmouseenter="this.style.background='rgba(255,255,255,0.15)';this.style.borderColor='#FCD34D'"
       onmouseleave="this.style.background='rgba(255,255,255,0.08)';this.style.borderColor='rgba(255,255,255,0.15)'"
    >
      <div style="font-size:18px;font-weight:700;color:white;font-family:'Fredoka',sans-serif;margin-bottom:4px">
        âœ¨ ${ep.question}
      </div>
      <div style="font-size:13px;color:#C4B5FD;font-family:'Fredoka',sans-serif;line-height:1.4">
        ${ep.answer_summary || 'Tap to replay!'}
      </div>
    </button>
  `).join('');
}

async function playLibraryEpisode(slug) {
  // Show loading
  document.getElementById('home').style.display = 'none';
  document.getElementById('loading').style.display = 'flex';
  document.getElementById('loading-text').textContent = 'Loading saved episode...';
  
  try {
    const res = await fetch('/api/library/' + slug);
    if (!res.ok) throw new Error('Episode not found');
    const episode = await res.json();
    startEpisode(episode);
  } catch (e) {
    console.error('Library play error:', e);
    document.getElementById('loading').style.display = 'none';
    document.getElementById('home').style.display = 'flex';
    alert('Could not load episode â€” try again!');
  }
}

// Load library on page load
document.addEventListener('DOMContentLoaded', loadLibrary);

function toggleSound() {
  ttsEnabled = !ttsEnabled;
  if (!ttsEnabled) stopAudio();
  render();
}

// â”€â”€â”€ RENDER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function render() {
  const app = document.getElementById('app');
  if (state.screen === "home") app.innerHTML = renderHome();
  else if (state.screen === "loading") app.innerHTML = renderLoading();
  else if (state.screen === "playing") app.innerHTML = renderPlayer();
}

// Boot
render();
</script>
</body>
</html>
